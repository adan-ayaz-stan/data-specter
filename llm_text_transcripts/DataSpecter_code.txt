
C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.CORE\DATASPECTER.CORE.CSPROJ CODE IS BELOW
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.CORE\INTERFACES\IENTROPYSERVICE.CS CODE IS BELOW
using DataSpecter.Core.Models;
using System.Threading.Tasks;

namespace DataSpecter.Core.Interfaces
{
    public interface IEntropyService
    {
        /// <summary>
        /// Calculates the Shannon entropy for chunks of the file.
        /// </summary>
        /// <param name="dataSource">The source data.</param>
        /// <param name="chunkSize">Size of the window to calculate entropy for.</param>
        /// <returns>An array of entropy values (0.0 to 8.0) for each chunk.</returns>
        Task<double[]> CalculateEntropyAsync(BinaryDataSource dataSource, int chunkSize = 1024);
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.CORE\INTERFACES\IFILESERVICE.CS CODE IS BELOW
﻿using DataSpecter.Core.Models;

namespace DataSpecter.Core.Interfaces
{
    public interface IFileService
    {
        /// <summary>
        /// Reads a file into a BinaryDataSource.
        /// </summary>
        BinaryDataSource OpenFile(string path);
        
        /// <summary>
        /// Saves the index (SA + LCP) to a file.
        /// </summary>
        Task SaveIndexAsync(string originalFilePath, int[] sa, int[] lcp);
        
        /// <summary>
        /// Loads the index (SA + LCP) if it exists.
        /// </summary>
        Task<(int[] sa, int[] lcp)?> LoadIndexAsync(string originalFilePath);
    }
}

C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.CORE\INTERFACES\IFUZZYHASHSERVICE.CS CODE IS BELOW
using DataSpecter.Core.Models;
using System.Threading.Tasks;

namespace DataSpecter.Core.Interfaces
{
    /// <summary>
    /// Service for fuzzy hashing (SSDEEP/CTPH) and file similarity comparison.
    /// </summary>
    public interface IFuzzyHashService
    {
        /// <summary>
        /// Computes the fuzzy hash (SSDEEP) of a file.
        /// </summary>
        /// <param name="dataSource">The binary data source.</param>
        /// <returns>The fuzzy hash string.</returns>
        Task<string> ComputeFuzzyHashAsync(BinaryDataSource dataSource);

        /// <summary>
        /// Compares two fuzzy hashes and returns a similarity score (0-100).
        /// </summary>
        /// <param name="hash1">First fuzzy hash.</param>
        /// <param name="hash2">Second fuzzy hash.</param>
        /// <returns>Similarity score from 0 (completely different) to 100 (identical).</returns>
        int CompareFuzzyHashes(string hash1, string hash2);

        /// <summary>
        /// Computes byte-level similarity between two files using LCP arrays.
        /// </summary>
        /// <param name="dataSource1">First file data source.</param>
        /// <param name="dataSource2">Second file data source.</param>
        /// <param name="suffixArray1">Suffix array of first file.</param>
        /// <param name="lcpArray1">LCP array of first file.</param>
        /// <returns>Similarity metrics including percentage and common substrings.</returns>
        Task<SimilarityResult> ComputeByteLevelSimilarityAsync(
            BinaryDataSource dataSource1,
            BinaryDataSource dataSource2,
            int[]? suffixArray1 = null,
            int[]? lcpArray1 = null);
    }

    /// <summary>
    /// Result of byte-level similarity comparison.
    /// </summary>
    public class SimilarityResult
    {
        /// <summary>
        /// Percentage of bytes in common (0.0 to 100.0).
        /// </summary>
        public double SimilarityPercentage { get; set; }

        /// <summary>
        /// Length of the longest common substring.
        /// </summary>
        public int LongestCommonSubstringLength { get; set; }

        /// <summary>
        /// Offset in file1 of the longest common substring.
        /// </summary>
        public long LongestCommonSubstringOffset1 { get; set; }

        /// <summary>
        /// Offset in file2 of the longest common substring.
        /// </summary>
        public long LongestCommonSubstringOffset2 { get; set; }

        /// <summary>
        /// Total bytes analyzed.
        /// </summary>
        public long TotalBytesAnalyzed { get; set; }

        /// <summary>
        /// Number of common chunks found.
        /// </summary>
        public int CommonChunksCount { get; set; }

        /// <summary>
        /// Calculation time in milliseconds.
        /// </summary>
        public long CalculationTimeMs { get; set; }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.CORE\INTERFACES\ILCSSERVICE.CS CODE IS BELOW
using DataSpecter.Core.Models;
using System.Threading.Tasks;

namespace DataSpecter.Core.Interfaces
{
    public interface ILcsService
    {
        /// <summary>
        /// Finds the Longest Common Substring between two data sources.
        /// </summary>
        /// <returns>Length of LCS, offset in source1, offset in source2</returns>
        Task<(long length, long offset1, long offset2)> FindLcsAsync(BinaryDataSource source1, BinaryDataSource source2);
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.CORE\INTERFACES\ISTRUCTUREPARSER.CS CODE IS BELOW
using DataSpecter.Core.Models;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace DataSpecter.Core.Interfaces
{
    public interface IStructureParser
    {
        bool CanParse(string fileName, byte[] headerBytes);
        Task<List<StructureItem>> ParseAsync(BinaryDataSource dataSource);
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.CORE\INTERFACES\ISUFFIXARRAYSERVICE.CS CODE IS BELOW
using DataSpecter.Core.Models;
using System;
using System.Threading.Tasks;

namespace DataSpecter.Core.Interfaces
{
    public interface ISuffixArrayService
    {
        /// <summary>
        /// Generates Suffix Array and LCP Array for the given data source.
        /// </summary>
        /// <param name="dataSource">The source data.</param>
        /// <param name="progress">Optional progress reporter for indexing updates.</param>
        /// <returns>A result containing the counts, timings, and arrays.</returns>
        Task<(long saCount, TimeSpan saTime, int[] suffixArray, long lcpCount, TimeSpan lcpTime, int[] lcpArray)> GenerateAsync(BinaryDataSource dataSource, IProgress<(string stage, int current, int total, double percentage)>? progress = null);

        /// <summary>
        /// Searches for a pattern using the Suffix Array (Binary Search).
        /// </summary>
        /// <param name="dataSource">The source data.</param>
        /// <param name="suffixArray">The pre-computed Suffix Array.</param>
        /// <param name="pattern">The byte pattern to search for.</param>
        /// <returns>A list of offsets where the pattern occurs.</returns>
        Task<long[]> SearchAsync(BinaryDataSource dataSource, int[] suffixArray, byte[] pattern);
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.CORE\MODELS\BINARYDATASOURCE.CS CODE IS BELOW
﻿using System;
using System.IO;
using System.IO.MemoryMappedFiles;

namespace DataSpecter.Core.Models
{
    /// <summary>
    /// Represents a handle to a forensic target file.
    /// abstracting away whether it is in RAM or on Disk.
    /// </summary>
    public class BinaryDataSource : IDisposable
    {
        private readonly MemoryMappedFile _mmf;
        private readonly MemoryMappedViewAccessor _accessor;
        private bool _disposed;

        public string FilePath { get; }
        public long Length { get; }

        public BinaryDataSource(string filePath)
        {
            if (!File.Exists(filePath))
                throw new FileNotFoundException("Target file not found", filePath);

            FilePath = filePath;
            var fileInfo = new FileInfo(filePath);
            Length = fileInfo.Length;

            // Map the file into virtual memory. 
            // "Capacity: 0" means map the whole file.
            _mmf = MemoryMappedFile.CreateFromFile(filePath, FileMode.Open, null, 0, MemoryMappedFileAccess.Read);

            // Create a view accessor to read bytes randomly.
            _accessor = _mmf.CreateViewAccessor(0, 0, MemoryMappedFileAccess.Read);
        }

        /// <summary>
        /// Reads a single byte at the specified index.
        /// Thread-safe and fast.
        /// </summary>
        public byte ReadByte(long offset)
        {
            if (offset < 0 || offset >= Length)
                throw new IndexOutOfRangeException();

            return _accessor.ReadByte(offset);
        }

        /// <summary>
        /// Reads a chunk of bytes into a buffer.
        /// Optimized for the Hex Viewer to grab a "screen's worth" of rows.
        /// </summary>
        public int ReadRange(long offset, byte[] buffer, int index, int count)
        {
            if (_disposed) throw new ObjectDisposedException(nameof(BinaryDataSource));

            // Clamp count if we are near the end of file
            long remaining = Length - offset;
            if (remaining <= 0) return 0;

            int toRead = (int)Math.Min(count, remaining);
            return _accessor.ReadArray(offset, buffer, index, toRead);
        }

        public void Dispose()
        {
            if (!_disposed)
            {
                _accessor?.Dispose();
                _mmf?.Dispose();
                _disposed = true;
            }
        }
    }
}

C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.CORE\MODELS\STRUCTUREITEM.CS CODE IS BELOW
using System.Collections.Generic;

namespace DataSpecter.Core.Models
{
    public class StructureItem
    {
        public string Name { get; set; } = string.Empty;
        public string Value { get; set; } = string.Empty;
        public long Offset { get; set; }
        public long Length { get; set; }
        public List<StructureItem> Children { get; set; } = new List<StructureItem>();

        public StructureItem(string name, string value, long offset, long length)
        {
            Name = name;
            Value = value;
            Offset = offset;
            Length = length;
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.INFRASTRUCTURE\DATASPECTER.INFRASTRUCTURE.CSPROJ CODE IS BELOW
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="dnYara" Version="2.1.0" />
    <PackageReference Include="ILGPU" Version="1.5.1" />
    <PackageReference Include="ILGPU.Algorithms" Version="1.5.1" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\DataSpecter.Core\DataSpecter.Core.csproj" />
  </ItemGroup>

</Project>


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.INFRASTRUCTURE\PARSERS\PDFPARSER.CS CODE IS BELOW
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using DataSpecter.Core.Interfaces;
using DataSpecter.Core.Models;

namespace DataSpecter.Infrastructure.Parsers
{
    public class PdfParser : IStructureParser
    {
        public bool CanParse(string fileName, byte[] headerBytes)
        {
            if (headerBytes.Length < 5) return false;
            // %PDF
            string head = Encoding.ASCII.GetString(headerBytes, 0, 5);
            return head.StartsWith("%PDF-");
        }

        public async Task<List<StructureItem>> ParseAsync(BinaryDataSource dataSource)
        {
            return await Task.Run(() =>
            {
                var root = new List<StructureItem>();
                
                // 1. Header
                byte[] buffer = new byte[1024];
                int read = dataSource.ReadRange(0, buffer, 0, 1024);
                string headStr = Encoding.ASCII.GetString(buffer, 0, read);
                
                // Find version
                var verMatch = Regex.Match(headStr, @"%PDF-(\d\.\d)");
                if (verMatch.Success)
                {
                    root.Add(new StructureItem("PDF Header", $"Version {verMatch.Groups[1].Value}", 0, verMatch.Length));
                }

                // 2. Scan for Objects (Simple scan in first 5MB for prototype)
                long scanLimit = Math.Min(dataSource.Length, 5 * 1024 * 1024);
                byte[] scanBuf = new byte[scanLimit];
                dataSource.ReadRange(0, scanBuf, 0, (int)scanLimit);
                string content = Encoding.ASCII.GetString(scanBuf);

                var objMatches = Regex.Matches(content, @"(\d+) (\d+) obj");
                var objectsNode = new StructureItem("PDF Objects", $"{objMatches.Count} found (in first 5MB)", 0, 0);
                
                int count = 0;
                foreach (Match m in objMatches)
                {
                    if (count++ > 50) 
                    {
                        objectsNode.Children.Add(new StructureItem("...", "More objects...", 0, 0));
                        break;
                    }
                    objectsNode.Children.Add(new StructureItem($"Object {m.Groups[1].Value}", $"Gen {m.Groups[2].Value}", m.Index, m.Length));
                }
                root.Add(objectsNode);

                // 3. Trailer?
                // Usually at the end. Read last 1KB.
                if (dataSource.Length > 1024)
                {
                    long tailOffset = dataSource.Length - 1024;
                    byte[] tailBuf = new byte[1024];
                    dataSource.ReadRange(tailOffset, tailBuf, 0, 1024);
                    string tailStr = Encoding.ASCII.GetString(tailBuf);
                    
                    int trailerIdx = tailStr.LastIndexOf("trailer");
                    if (trailerIdx >= 0)
                    {
                        root.Add(new StructureItem("Trailer", "Found", tailOffset + trailerIdx, 7));
                    }
                }
                
                return root;
            });
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.INFRASTRUCTURE\PARSERS\PEPARSER.CS CODE IS BELOW
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using DataSpecter.Core.Interfaces;
using DataSpecter.Core.Models;

namespace DataSpecter.Infrastructure.Parsers
{
    public class PeParser : IStructureParser
    {
        public bool CanParse(string fileName, byte[] headerBytes)
        {
            if (headerBytes.Length < 2) return false;
            // MZ signature
            return headerBytes[0] == 0x4D && headerBytes[1] == 0x5A;
        }

        public async Task<List<StructureItem>> ParseAsync(BinaryDataSource dataSource)
        {
            return await Task.Run(() =>
            {
                var root = new List<StructureItem>();
                try
                {
                    // 1. DOS Header
                    byte[] dosHeader = new byte[64];
                    dataSource.ReadRange(0, dosHeader, 0, 64);
                    
                    var dosNode = new StructureItem("DOS Header", "", 0, 64);
                    dosNode.Children.Add(new StructureItem("e_magic", "MZ", 0, 2));
                    
                    int e_lfanew = BitConverter.ToInt32(dosHeader, 0x3C);
                    dosNode.Children.Add(new StructureItem("e_lfanew", $"0x{e_lfanew:X}", 0x3C, 4));
                    
                    root.Add(dosNode);

                    // 2. PE Header
                    if (e_lfanew > 0 && e_lfanew < dataSource.Length - 4)
                    {
                        byte[] peSig = new byte[4];
                        dataSource.ReadRange(e_lfanew, peSig, 0, 4);
                        if (peSig[0] == 'P' && peSig[1] == 'E' && peSig[2] == 0 && peSig[3] == 0)
                        {
                            var peNode = new StructureItem("NT Headers", "PE Signature", e_lfanew, 4);
                            root.Add(peNode);
                            
                            // File Header (20 bytes after PE sig)
                            long fileHeaderOffset = e_lfanew + 4;
                            byte[] fileHeader = new byte[20];
                            dataSource.ReadRange(fileHeaderOffset, fileHeader, 0, 20);
                            
                            var fhNode = new StructureItem("File Header", "", fileHeaderOffset, 20);
                            short numberOfSections = BitConverter.ToInt16(fileHeader, 2);
                            fhNode.Children.Add(new StructureItem("Machine", $"0x{BitConverter.ToInt16(fileHeader, 0):X4}", fileHeaderOffset, 2));
                            fhNode.Children.Add(new StructureItem("NumberOfSections", numberOfSections.ToString(), fileHeaderOffset + 2, 2));
                            peNode.Children.Add(fhNode);

                            // Optional Header (Standard + Windows fields)
                            long optHeaderOffset = fileHeaderOffset + 20;
                            short sizeOfOptionalHeader = BitConverter.ToInt16(fileHeader, 16);
                            
                            if (sizeOfOptionalHeader > 0)
                            {
                                byte[] optHeader = new byte[sizeOfOptionalHeader];
                                dataSource.ReadRange(optHeaderOffset, optHeader, 0, sizeOfOptionalHeader);
                                var optNode = new StructureItem("Optional Header", "", optHeaderOffset, sizeOfOptionalHeader);
                                
                                short magic = BitConverter.ToInt16(optHeader, 0);
                                string magicType = (magic == 0x10b) ? "PE32" : (magic == 0x20b) ? "PE32+" : "Unknown";
                                optNode.Children.Add(new StructureItem("Magic", $"{magicType} (0x{magic:X})", optHeaderOffset, 2));
                                
                                int entryPoint = BitConverter.ToInt32(optHeader, 16);
                                optNode.Children.Add(new StructureItem("AddressOfEntryPoint", $"0x{entryPoint:X}", optHeaderOffset + 16, 4));

                                peNode.Children.Add(optNode);
                            }

                            // Sections
                            long sectionHeadersOffset = optHeaderOffset + sizeOfOptionalHeader;
                            var sectionsNode = new StructureItem("Section Headers", $"{numberOfSections} Sections", sectionHeadersOffset, numberOfSections * 40);
                            
                            for(int i=0; i<numberOfSections; i++)
                            {
                                long offset = sectionHeadersOffset + (i * 40);
                                byte[] secData = new byte[40];
                                dataSource.ReadRange(offset, secData, 0, 40);
                                
                                string name = Encoding.ASCII.GetString(secData, 0, 8).TrimEnd('\0');
                                int virtualSize = BitConverter.ToInt32(secData, 8);
                                int virtualAddress = BitConverter.ToInt32(secData, 12);
                                int rawSize = BitConverter.ToInt32(secData, 16);
                                int rawPointer = BitConverter.ToInt32(secData, 20);
                                
                                var secNode = new StructureItem($"Section {i}", name, offset, 40);
                                secNode.Children.Add(new StructureItem("Name", name, offset, 8));
                                secNode.Children.Add(new StructureItem("Virtual Size", $"0x{virtualSize:X}", offset + 8, 4));
                                secNode.Children.Add(new StructureItem("Virtual Address", $"0x{virtualAddress:X}", offset + 12, 4));
                                secNode.Children.Add(new StructureItem("Raw Size", $"0x{rawSize:X}", offset + 16, 4));
                                secNode.Children.Add(new StructureItem("Raw Pointer", $"0x{rawPointer:X}", offset + 20, 4));
                                
                                sectionsNode.Children.Add(secNode);
                            }
                            root.Add(sectionsNode);
                        }
                    }
                }
                catch (Exception) { /* Handle read errors */ }
                
                return root;
            });
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.INFRASTRUCTURE\SERVICES\ENTROPYSERVICE.CS CODE IS BELOW
using System;
using System.Threading.Tasks;
using DataSpecter.Core.Interfaces;
using DataSpecter.Core.Models;

namespace DataSpecter.Infrastructure.Services
{
    public class EntropyService : IEntropyService
    {
        public async Task<double[]> CalculateEntropyAsync(BinaryDataSource dataSource, int chunkSize = 1024)
        {
            long length = dataSource.Length;
            int numChunks = (int)((length + chunkSize - 1) / chunkSize);
            double[] entropyValues = new double[numChunks];

            // Limit memory usage - process in chunks, maybe parallelize later
            // For now, simple sequential async implementation
            return await Task.Run(() =>
            {
                byte[] buffer = new byte[chunkSize];
                
                for (int i = 0; i < numChunks; i++)
                {
                    long offset = (long)i * chunkSize;
                    int read = dataSource.ReadRange(offset, buffer, 0, chunkSize);
                    
                    if (read > 0)
                    {
                        entropyValues[i] = CalculateShannonEntropy(buffer, read);
                    }
                }

                return entropyValues;
            });
        }

        private double CalculateShannonEntropy(byte[] buffer, int count)
        {
            if (count == 0) return 0.0;

            int[] frequencies = new int[256];
            for (int i = 0; i < count; i++)
            {
                frequencies[buffer[i]]++;
            }

            double entropy = 0.0;
            double log2 = Math.Log(2);

            for (int i = 0; i < 256; i++)
            {
                if (frequencies[i] > 0)
                {
                    double p = (double)frequencies[i] / count;
                    entropy -= p * (Math.Log(p) / log2);
                }
            }

            return entropy;
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.INFRASTRUCTURE\SERVICES\FILESERVICE.CS CODE IS BELOW
﻿using System;
using System.IO;
using DataSpecter.Core.Interfaces;
using DataSpecter.Core.Models;

namespace DataSpecter.Infrastructure.Services
{
    public class FileService : IFileService
    {
        public BinaryDataSource OpenFile(string path)
        {
            if (!File.Exists(path)) throw new FileNotFoundException("File not found", path);
            return new BinaryDataSource(path);
        }

        public async Task SaveIndexAsync(string originalFilePath, int[] sa, int[] lcp)
        {
            string idxPath = originalFilePath + ".idx";
            await Task.Run(() =>
            {
                using (var fs = new FileStream(idxPath, FileMode.Create, FileAccess.Write, FileShare.None))
                using (var bw = new BinaryWriter(fs))
                {
                    // Version header
                    bw.Write(1); 
                    
                    // Length check
                    bw.Write(sa.Length);
                    
                    // Write SA
                    foreach (var val in sa) bw.Write(val);
                    
                    // Write LCP
                    foreach (var val in lcp) bw.Write(val);
                }
            });
        }

        public async Task<(int[] sa, int[] lcp)?> LoadIndexAsync(string originalFilePath)
        {
            string idxPath = originalFilePath + ".idx";
            if (!File.Exists(idxPath)) return null;

            return await Task.Run(() =>
            {
                try
                {
                    using (var fs = new FileStream(idxPath, FileMode.Open, FileAccess.Read, FileShare.Read))
                    using (var br = new BinaryReader(fs))
                    {
                        int version = br.ReadInt32();
                        if (version != 1) return ((int[] sa, int[] lcp)?)null; 

                        int len = br.ReadInt32();
                        
                        int[] sa = new int[len];
                        for(int i=0; i<len; i++) sa[i] = br.ReadInt32();
                        
                        int[] lcp = new int[len];
                        for(int i=0; i<len; i++) lcp[i] = br.ReadInt32();
                        
                        return ((int[] sa, int[] lcp)?)(sa, lcp);
                    }
                }
                catch
                {
                    // Corrupt index or read error, ignore and force rebuild
                    return ((int[] sa, int[] lcp)?)null;
                }
            });
        }
    }
}

C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.INFRASTRUCTURE\SERVICES\FUZZYHASHSERVICE.CS CODE IS BELOW
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using DataSpecter.Core.Interfaces;
using DataSpecter.Core.Models;

namespace DataSpecter.Infrastructure.Services
{
    /// <summary>
    /// Implementation of fuzzy hashing (SSDEEP/CTPH) and file similarity comparison.
    /// </summary>
    public class FuzzyHashService : IFuzzyHashService
    {
        private const int MinBlockSize = 3;
        private const int MaxBlockSize = 3 * 1024 * 1024; // 3MB max block size
        private const int SpamSumLength = 64;
        private const int RollingWindow = 7;

        /// <summary>
        /// Computes the fuzzy hash (SSDEEP) of a file.
        /// </summary>
        public async Task<string> ComputeFuzzyHashAsync(BinaryDataSource dataSource)
        {
            return await Task.Run(() =>
            {
                long fileSize = dataSource.Length;
                
                // Calculate appropriate block size
                int blockSize = CalculateBlockSize(fileSize);
                
                // Compute two signatures with different block sizes
                var signature1 = ComputeSignature(dataSource, blockSize);
                var signature2 = ComputeSignature(dataSource, blockSize * 2);
                
                // Format as SSDEEP hash: blocksize:signature1:signature2
                return $"{blockSize}:{signature1}:{signature2}";
            });
        }

        /// <summary>
        /// Compares two fuzzy hashes and returns a similarity score (0-100).
        /// </summary>
        public int CompareFuzzyHashes(string hash1, string hash2)
        {
            if (string.IsNullOrEmpty(hash1) || string.IsNullOrEmpty(hash2))
                return 0;

            var parts1 = hash1.Split(':');
            var parts2 = hash2.Split(':');

            if (parts1.Length != 3 || parts2.Length != 3)
                return 0;

            int blockSize1 = int.Parse(parts1[0]);
            int blockSize2 = int.Parse(parts2[0]);

            // Block sizes must be compatible (same or factor of 2)
            if (blockSize1 != blockSize2 && blockSize1 != blockSize2 * 2 && blockSize2 != blockSize1 * 2)
                return 0;

            // Compare signatures
            int score1 = CompareSignatures(parts1[1], parts2[1]);
            int score2 = CompareSignatures(parts1[2], parts2[2]);
            
            // Also try cross-comparison for different block sizes
            int score3 = CompareSignatures(parts1[1], parts2[2]);
            int score4 = CompareSignatures(parts1[2], parts2[1]);

            return Math.Max(Math.Max(score1, score2), Math.Max(score3, score4));
        }

        /// <summary>
        /// Computes byte-level similarity using common substring analysis.
        /// </summary>
        public async Task<SimilarityResult> ComputeByteLevelSimilarityAsync(
            BinaryDataSource dataSource1,
            BinaryDataSource dataSource2,
            int[]? suffixArray1 = null,
            int[]? lcpArray1 = null)
        {
            return await Task.Run(() =>
            {
                var sw = Stopwatch.StartNew();
                
                long size1 = dataSource1.Length;
                long size2 = dataSource2.Length;
                
                // For very large files, sample chunks for performance
                const int maxSampleSize = 10 * 1024 * 1024; // 10MB sample
                const int chunkSize = 4096; // 4KB chunks
                
                long sampleSize1 = Math.Min(size1, maxSampleSize);
                long sampleSize2 = Math.Min(size2, maxSampleSize);
                
                // Calculate number of chunks to sample
                int numChunks1 = (int)((sampleSize1 + chunkSize - 1) / chunkSize);
                int numChunks2 = (int)((sampleSize2 + chunkSize - 1) / chunkSize);
                
                // Hash each chunk for fast comparison
                var chunks1 = HashChunks(dataSource1, numChunks1, chunkSize);
                var chunks2 = HashChunks(dataSource2, numChunks2, chunkSize);
                
                // Find common chunks
                var commonChunks = chunks1.Keys.Intersect(chunks2.Keys).ToList();
                int commonChunksCount = commonChunks.Count;
                
                // Calculate similarity percentage
                int totalChunks = Math.Max(numChunks1, numChunks2);
                double similarityPercentage = totalChunks > 0 
                    ? (commonChunksCount * 100.0 / totalChunks) 
                    : 0.0;
                
                // Find longest common substring
                var (longestLength, offset1, offset2) = FindLongestCommonSubstring(
                    dataSource1, dataSource2, Math.Min(size1, maxSampleSize / 2));
                
                sw.Stop();
                
                return new SimilarityResult
                {
                    SimilarityPercentage = similarityPercentage,
                    LongestCommonSubstringLength = longestLength,
                    LongestCommonSubstringOffset1 = offset1,
                    LongestCommonSubstringOffset2 = offset2,
                    TotalBytesAnalyzed = Math.Min(sampleSize1, sampleSize2),
                    CommonChunksCount = commonChunksCount,
                    CalculationTimeMs = sw.ElapsedMilliseconds
                };
            });
        }

        #region SSDEEP Implementation

        private int CalculateBlockSize(long fileSize)
        {
            // Calculate block size so we get approximately 64 hash points
            int blockSize = (int)(fileSize / SpamSumLength);
            
            // Ensure it's at least MinBlockSize
            if (blockSize < MinBlockSize)
                blockSize = MinBlockSize;
            
            // Round to nearest power of 2
            blockSize = (int)Math.Pow(2, Math.Floor(Math.Log(blockSize) / Math.Log(2)));
            
            // Clamp to valid range
            return Math.Max(MinBlockSize, Math.Min(MaxBlockSize, blockSize));
        }

        private string ComputeSignature(BinaryDataSource dataSource, int blockSize)
        {
            var signature = new StringBuilder();
            var rollingHash = new RollingHash(RollingWindow);
            
            byte[] buffer = new byte[8192]; // 8KB read buffer
            long offset = 0;
            long length = dataSource.Length;
            
            uint blockHash = 0;
            int blockPos = 0;
            
            const string base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            
            while (offset < length && signature.Length < SpamSumLength)
            {
                int toRead = (int)Math.Min(buffer.Length, length - offset);
                int read = dataSource.ReadRange(offset, buffer, 0, toRead);
                
                if (read == 0) break;
                
                for (int i = 0; i < read && signature.Length < SpamSumLength; i++)
                {
                    byte b = buffer[i];
                    
                    // Update rolling hash
                    rollingHash.Update(b);
                    
                    // Update block hash (FNV-1a)
                    blockHash ^= b;
                    blockHash *= 0x01000193;
                    
                    blockPos++;
                    
                    // Check if we've hit a block boundary
                    if (rollingHash.Sum % blockSize == (blockSize - 1))
                    {
                        signature.Append(base64Chars[(int)(blockHash % 64)]);
                        blockHash = 0;
                        blockPos = 0;
                    }
                }
                
                offset += read;
            }
            
            // Add final partial block if any
            if (blockPos > 0 && signature.Length < SpamSumLength)
            {
                signature.Append(base64Chars[(int)(blockHash % 64)]);
            }
            
            return signature.ToString();
        }

        private int CompareSignatures(string sig1, string sig2)
        {
            if (string.IsNullOrEmpty(sig1) || string.IsNullOrEmpty(sig2))
                return 0;

            int len1 = sig1.Length;
            int len2 = sig2.Length;
            
            // Use edit distance (Levenshtein) to compare signatures
            int distance = ComputeEditDistance(sig1, sig2);
            
            // Convert distance to similarity score (0-100)
            int maxLen = Math.Max(len1, len2);
            if (maxLen == 0) return 100;
            
            int score = (int)(100 * (1.0 - (double)distance / maxLen));
            return Math.Max(0, Math.Min(100, score));
        }

        private int ComputeEditDistance(string s1, string s2)
        {
            int m = s1.Length;
            int n = s2.Length;
            
            // Use space-optimized version (single row)
            int[] prev = new int[n + 1];
            int[] curr = new int[n + 1];
            
            for (int j = 0; j <= n; j++)
                prev[j] = j;
            
            for (int i = 1; i <= m; i++)
            {
                curr[0] = i;
                
                for (int j = 1; j <= n; j++)
                {
                    int cost = s1[i - 1] == s2[j - 1] ? 0 : 1;
                    curr[j] = Math.Min(Math.Min(
                        curr[j - 1] + 1,      // Insert
                        prev[j] + 1),         // Delete
                        prev[j - 1] + cost);  // Replace
                }
                
                var temp = prev;
                prev = curr;
                curr = temp;
            }
            
            return prev[n];
        }

        #endregion

        #region Similarity Comparison

        private Dictionary<ulong, List<long>> HashChunks(BinaryDataSource dataSource, int numChunks, int chunkSize)
        {
            var chunkHashes = new Dictionary<ulong, List<long>>();
            byte[] buffer = new byte[chunkSize];
            
            for (int i = 0; i < numChunks; i++)
            {
                long offset = (long)i * chunkSize;
                int read = dataSource.ReadRange(offset, buffer, 0, chunkSize);
                
                if (read > 0)
                {
                    ulong hash = ComputeFNV1aHash(buffer, read);
                    
                    if (!chunkHashes.ContainsKey(hash))
                        chunkHashes[hash] = new List<long>();
                    
                    chunkHashes[hash].Add(offset);
                }
            }
            
            return chunkHashes;
        }

        private ulong ComputeFNV1aHash(byte[] data, int length)
        {
            const ulong FnvPrime = 0x00000100000001B3;
            const ulong FnvOffsetBasis = 0xcbf29ce484222325;
            
            ulong hash = FnvOffsetBasis;
            
            for (int i = 0; i < length; i++)
            {
                hash ^= data[i];
                hash *= FnvPrime;
            }
            
            return hash;
        }

        private (int length, long offset1, long offset2) FindLongestCommonSubstring(
            BinaryDataSource dataSource1, 
            BinaryDataSource dataSource2, 
            long maxBytesToCheck)
        {
            const int minMatchLength = 16; // Minimum meaningful match
            int longestLength = 0;
            long bestOffset1 = 0;
            long bestOffset2 = 0;
            
            // Use a sliding window approach with hashing
            const int windowSize = 256;
            byte[] window1 = new byte[windowSize];
            byte[] window2 = new byte[windowSize];
            
            long size1 = Math.Min(dataSource1.Length, maxBytesToCheck);
            long size2 = Math.Min(dataSource2.Length, maxBytesToCheck);
            
            // Sample at intervals for performance
            int sampleInterval = Math.Max(1, (int)(size1 / 1000));
            
            for (long offset1 = 0; offset1 < size1 - minMatchLength; offset1 += sampleInterval)
            {
                int read1 = dataSource1.ReadRange(offset1, window1, 0, windowSize);
                if (read1 < minMatchLength) continue;
                
                ulong hash1 = ComputeFNV1aHash(window1, Math.Min(read1, 64));
                
                // Search for this pattern in file2
                for (long offset2 = 0; offset2 < size2 - minMatchLength; offset2 += sampleInterval)
                {
                    int read2 = dataSource2.ReadRange(offset2, window2, 0, windowSize);
                    if (read2 < minMatchLength) continue;
                    
                    ulong hash2 = ComputeFNV1aHash(window2, Math.Min(read2, 64));
                    
                    // Quick hash check first
                    if (hash1 != hash2) continue;
                    
                    // Found potential match, now verify and extend
                    int matchLength = 0;
                    long checkOffset1 = offset1;
                    long checkOffset2 = offset2;
                    
                    while (checkOffset1 < size1 && checkOffset2 < size2 && matchLength < windowSize)
                    {
                        byte b1 = window1[matchLength];
                        byte b2 = window2[matchLength];
                        
                        if (b1 != b2) break;
                        
                        matchLength++;
                    }
                    
                    if (matchLength > longestLength)
                    {
                        longestLength = matchLength;
                        bestOffset1 = offset1;
                        bestOffset2 = offset2;
                    }
                }
            }
            
            return (longestLength, bestOffset1, bestOffset2);
        }

        #endregion

        #region Rolling Hash

        private class RollingHash
        {
            private readonly int _windowSize;
            private readonly byte[] _window;
            private int _position;
            private uint _sum;

            public RollingHash(int windowSize)
            {
                _windowSize = windowSize;
                _window = new byte[windowSize];
                _position = 0;
                _sum = 0;
            }

            public void Update(byte b)
            {
                // Remove oldest byte's contribution
                _sum -= _window[_position];
                
                // Add new byte
                _window[_position] = b;
                _sum += b;
                
                // Move position
                _position = (_position + 1) % _windowSize;
            }

            public uint Sum => _sum;
        }

        #endregion
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.INFRASTRUCTURE\SERVICES\GPUSUFFIXARRAYSERVICE.CS CODE IS BELOW
using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using DataSpecter.Core.Interfaces;
using DataSpecter.Core.Models;
using ILGPU;
using ILGPU.Runtime;
using ILGPU.Runtime.Cuda;
using ILGPU.Runtime.CPU;

namespace DataSpecter.Infrastructure.Services
{
    /// <summary>
    /// GPU-accelerated suffix array service using ILGPU.
    /// Currently uses parallel CPU operations. GPU kernels for suffix array
    /// construction are complex and require careful implementation.
    /// </summary>
    public class GpuSuffixArrayService : ISuffixArrayService
    {
        private readonly Context? _context;
        private readonly Accelerator? _accelerator;
        private readonly bool _isGpuAvailable;
        
        // Cache for suffix arrays
        private readonly ConcurrentDictionary<string, (int[] sa, int[] lcp, long size, DateTime modified)> _cache = new();
        private const int MAX_CACHE_ENTRIES = 5;

        public GpuSuffixArrayService()
        {
            _context = Context.Create(builder => builder.Default().EnableAlgorithms());
            
            // Try to get CUDA GPU first, fall back to CPU
            try
            {
                _accelerator = _context.CreateCudaAccelerator(0);
                _isGpuAvailable = true;
                Debug.WriteLine($"[GpuSuffixArrayService] Using GPU: {_accelerator.Name}");
            }
            catch
            {
                _accelerator = _context.CreateCPUAccelerator(0);
                _isGpuAvailable = false;
                Debug.WriteLine("[GpuSuffixArrayService] GPU not available, using CPU accelerator");
            }
        }

        public async Task<(long saCount, TimeSpan saTime, int[] suffixArray, long lcpCount, TimeSpan lcpTime, int[] lcpArray)> GenerateAsync(
            BinaryDataSource dataSource, 
            IProgress<(string stage, int current, int total, double percentage)>? progress = null)
        {
            long length = dataSource.Length;
            if (length > 100 * 1024 * 1024)
            {
                throw new InvalidOperationException("File too large for in-memory Suffix Array generation (Limit: 100MB)");
            }

            // Check cache
            string cacheKey = GetCacheKey(dataSource);
            if (_cache.TryGetValue(cacheKey, out var cached))
            {
                progress?.Report(($"Loaded from cache ({(_isGpuAvailable ? "GPU" : "CPU")} mode)", 100, 100, 100));
                return ((long)cached.sa.Length, TimeSpan.Zero, cached.sa, (long)cached.lcp.Length, TimeSpan.Zero, cached.lcp);
            }

            progress?.Report(("Loading file into memory", 0, 100, 0));
            byte[] data = new byte[length];
            dataSource.ReadRange(0, data, 0, (int)length);
            progress?.Report(("Loading file into memory", 100, 100, 100));

            return await Task.Run(() =>
            {
                int n = data.Length;

                // Build Suffix Array using GPU
                progress?.Report(($"Building Suffix Array ({(_isGpuAvailable ? "GPU" : "CPU")})", 0, n, 0));
                var sw = Stopwatch.StartNew();
                
                int[] sa = BuildSuffixArrayGpu(data, progress);
                
                sw.Stop();
                var saTime = sw.Elapsed;
                progress?.Report(("Building Suffix Array", n, n, 100));

                // Verify suffix array is correctly sorted
                bool isValid = VerifySuffixArray(data, sa);
                Debug.WriteLine($"[GpuSuffixArrayService] Suffix array verification: {(isValid ? "PASSED" : "FAILED")}");
                if (!isValid)
                {
                    throw new InvalidOperationException("Suffix array construction failed - array is not properly sorted");
                }

                // Build LCP Array
                progress?.Report(("Building LCP Array", 0, n, 0));
                sw.Restart();
                
                int[] rank = new int[n];
                Parallel.For(0, n, i => rank[sa[i]] = i);
                int[] lcp = BuildLCPArrayOptimized(data, sa, rank, progress);
                
                sw.Stop();
                var lcpTime = sw.Elapsed;
                progress?.Report(("Building LCP Array", n, n, 100));

                progress?.Report(("Complete", n, n, 100));
                
                StoreInCache(cacheKey, sa, lcp, length, dataSource);
                
                return ((long)n, saTime, sa, (long)n, lcpTime, lcp);
            });
        }

        private int[] BuildSuffixArrayGpu(byte[] data, IProgress<(string stage, int current, int total, double percentage)>? progress)
        {
            int n = data.Length;
            int[] sa = new int[n];
            int[] rank = new int[n];
            int[] tempRank = new int[n];
            int[] tempSa = new int[n];

            // Initial ranking based on first character - parallelized
            Parallel.For(0, n, i =>
            {
                sa[i] = i;
                rank[i] = data[i];
            });

            // Initial counting sort by first byte (0-255 range)
            CountingSortBySingleKey(sa, rank, tempSa, n, 256);
            Array.Copy(tempSa, sa, n);

            // Update initial ranks based on sorted order
            tempRank[sa[0]] = 0;
            for (int i = 1; i < n; i++)
            {
                tempRank[sa[i]] = tempRank[sa[i - 1]];
                if (data[sa[i]] != data[sa[i - 1]])
                    tempRank[sa[i]]++;
            }
            Array.Copy(tempRank, rank, n);

            // Preallocate key arrays to reuse
            int[] firstKeys = new int[n];
            int[] secondKeys = new int[n];

            // Doubling algorithm - sort by first 2k characters in each iteration
            for (int k = 1; k < n; k *= 2)
            {
                int maxRank = tempRank[sa[n - 1]] + 1;
                int currentK = k; // Capture for lambda
                
                // First pass: sort by second key (rank[i+k])
                Parallel.For(0, n, i =>
                {
                    int idx = sa[i];
                    secondKeys[i] = (idx + currentK < n) ? rank[idx + currentK] : -1;
                });
                
                // Counting sort by second key (handles -1 to maxRank range)
                CountingSortByKey(sa, secondKeys, tempSa, n, maxRank);
                Array.Copy(tempSa, sa, n);
                
                // Second pass: stable sort by first key (rank[i])
                Parallel.For(0, n, i =>
                {
                    firstKeys[i] = rank[sa[i]];
                });
                
                CountingSortByKey(sa, firstKeys, tempSa, n, maxRank);
                Array.Copy(tempSa, sa, n);

                // Update ranks based on new sorted order - parallelizable
                tempRank[sa[0]] = 0;
                for (int i = 1; i < n; i++)
                {
                    int prevIdx = sa[i - 1];
                    int currIdx = sa[i];
                    
                    int prevRank1 = rank[prevIdx];
                    int prevRank2 = (prevIdx + currentK < n) ? rank[prevIdx + currentK] : -1;
                    
                    int currRank1 = rank[currIdx];
                    int currRank2 = (currIdx + currentK < n) ? rank[currIdx + currentK] : -1;
                    
                    tempRank[currIdx] = tempRank[prevIdx];
                    if (currRank1 != prevRank1 || currRank2 != prevRank2)
                    {
                        tempRank[currIdx]++;
                    }
                }

                Array.Copy(tempRank, rank, n);

                // Early termination if all ranks are unique
                if (tempRank[sa[n - 1]] == n - 1)
                    break;

                progress?.Report(($"Building Suffix Array ({(_isGpuAvailable ? "GPU" : "CPU")})", k * 2, n, Math.Min(100, (k * 2 * 100.0) / n)));
            }

            return sa;
        }

        /// <summary>
        /// Counting sort for initial byte-based ranking (0-255 range)
        /// </summary>
        private void CountingSortBySingleKey(int[] sa, int[] keys, int[] output, int n, int keyRange)
        {
            int[] count = new int[keyRange];
            
            // Count occurrences
            for (int i = 0; i < n; i++)
            {
                count[keys[sa[i]]]++;
            }
            
            // Compute cumulative counts
            for (int i = 1; i < keyRange; i++)
            {
                count[i] += count[i - 1];
            }
            
            // Place elements in sorted order (reverse to maintain stability)
            for (int i = n - 1; i >= 0; i--)
            {
                int key = keys[sa[i]];
                output[--count[key]] = sa[i];
            }
        }

        /// <summary>
        /// Counting sort for rank-based sorting (handles negative keys by offsetting)
        /// </summary>
        private void CountingSortByKey(int[] sa, int[] keys, int[] output, int n, int maxKey)
        {
            // Offset to handle -1 values
            int offset = 1;
            int keyRange = maxKey + offset + 1;
            int[] count = new int[keyRange];
            
            // Count occurrences
            for (int i = 0; i < n; i++)
            {
                count[keys[i] + offset]++;
            }
            
            // Compute cumulative counts
            for (int i = 1; i < keyRange; i++)
            {
                count[i] += count[i - 1];
            }
            
            // Place elements in sorted order (reverse to maintain stability)
            for (int i = n - 1; i >= 0; i--)
            {
                int key = keys[i] + offset;
                output[--count[key]] = sa[i];
            }
        }

        /// <summary>
        /// Verifies that the suffix array is correctly sorted.
        /// Used for debugging and testing.
        /// </summary>
        private bool VerifySuffixArray(byte[] data, int[] sa)
        {
            int n = sa.Length;
            
            // Check that all indices 0..n-1 appear exactly once
            bool[] seen = new bool[n];
            for (int i = 0; i < n; i++)
            {
                if (sa[i] < 0 || sa[i] >= n || seen[sa[i]])
                    return false;
                seen[sa[i]] = true;
            }

            // Check that suffixes are in sorted order
            for (int i = 0; i < n - 1; i++)
            {
                int pos1 = sa[i];
                int pos2 = sa[i + 1];
                
                // Compare the two suffixes
                int cmp = CompareSuffixes(data, pos1, pos2);
                if (cmp > 0)
                {
                    Debug.WriteLine($"[VerifySuffixArray] ERROR: Suffix at sa[{i}]={pos1} is greater than suffix at sa[{i+1}]={pos2}");
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Compares two suffixes starting at given positions.
        /// Returns: <0 if suffix1 < suffix2, 0 if equal, >0 if suffix1 > suffix2
        /// </summary>
        private int CompareSuffixes(byte[] data, int pos1, int pos2)
        {
            int n = data.Length;
            int len = Math.Min(n - pos1, n - pos2);
            
            for (int i = 0; i < len; i++)
            {
                if (data[pos1 + i] < data[pos2 + i]) return -1;
                if (data[pos1 + i] > data[pos2 + i]) return 1;
            }
            
            // If one suffix is a prefix of the other, the shorter one is smaller
            return (n - pos1).CompareTo(n - pos2);
        }

        private int[] BuildLCPArrayOptimized(byte[] data, int[] sa, int[] rank, IProgress<(string stage, int current, int total, double percentage)>? progress)
        {
            int n = data.Length;
            int[] lcp = new int[n];
            int h = 0;
            int reportInterval = Math.Max(1, n / 100);

            for (int i = 0; i < n; i++)
            {
                if (i % reportInterval == 0)
                {
                    progress?.Report(("Building LCP Array", i, n, (i * 100.0) / n));
                }

                if (rank[i] > 0)
                {
                    int j = sa[rank[i] - 1];
                    while (i + h < n && j + h < n && data[i + h] == data[j + h])
                    {
                        h++;
                    }
                    lcp[rank[i]] = h;
                    if (h > 0) h--;
                }
            }

            return lcp;
        }

        public async Task<long[]> SearchAsync(BinaryDataSource dataSource, int[] sa, byte[] pattern)
        {
            if (pattern == null || pattern.Length == 0) return Array.Empty<long>();

            return await Task.Run(() =>
            {
                int n = sa.Length;
                Debug.WriteLine($"[GpuSuffixArrayService.SearchAsync] Starting search for pattern of length {pattern.Length} in suffix array of length {n}");
                Debug.WriteLine($"[GpuSuffixArrayService.SearchAsync] Pattern bytes: {string.Join(" ", pattern.Select(b => b.ToString("X2")))}");
                Debug.WriteLine($"[GpuSuffixArrayService.SearchAsync] DataSource length: {dataSource.Length}");

                // Binary search for lower bound
                int l = 0, r = n - 1;
                int start = -1;

                while (l <= r)
                {
                    int mid = l + (r - l) / 2;
                    int suffixStart = sa[mid];
                    int cmp = Compare(dataSource, suffixStart, pattern);
                    
                    Debug.WriteLine($"[GpuSuffixArrayService.SearchAsync] Binary search: mid={mid}, suffixStart={suffixStart}, cmp={cmp}");

                    if (cmp >= 0)
                    {
                        if (cmp == 0) start = mid;
                        r = mid - 1;
                    }
                    else
                    {
                        l = mid + 1;
                    }
                }

                Debug.WriteLine($"[GpuSuffixArrayService.SearchAsync] Lower bound search complete. start = {start}");
                if (start == -1)
                {
                    Debug.WriteLine($"[GpuSuffixArrayService.SearchAsync] No matches found - start is -1");
                    return Array.Empty<long>();
                }

                // Binary search for upper bound
                l = start;
                r = n - 1;
                int end = -1;

                while (l <= r)
                {
                    int mid = l + (r - l) / 2;
                    int suffixStart = sa[mid];
                    int cmp = Compare(dataSource, suffixStart, pattern);

                    if (cmp <= 0)
                    {
                        if (cmp == 0) end = mid;
                        l = mid + 1;
                    }
                    else
                    {
                        r = mid - 1;
                    }
                }

                Debug.WriteLine($"[GpuSuffixArrayService.SearchAsync] Upper bound search complete. end = {end}");
                if (end == -1)
                {
                    Debug.WriteLine($"[GpuSuffixArrayService.SearchAsync] Returning single match at offset {sa[start]}");
                    return new long[] { sa[start] };
                }

                // Collect results
                int count = end - start + 1;
                Debug.WriteLine($"[GpuSuffixArrayService.SearchAsync] Found {count} matches between indices {start} and {end}");
                long[] offsets = new long[count];
                for (int i = 0; i < count; i++)
                {
                    offsets[i] = sa[start + i];
                }

                Array.Sort(offsets);
                Debug.WriteLine($"[GpuSuffixArrayService.SearchAsync] Returning {offsets.Length} results. First few: {string.Join(", ", offsets.Take(5))}");
                return offsets;
            });
        }

        private int Compare(BinaryDataSource dataSource, int textOffset, byte[] pattern)
        {
            long len = dataSource.Length;
            int limit = pattern.Length;

            if (textOffset >= len) return -1;

            int availableBytes = (int)Math.Min(limit, len - textOffset);
            byte[] buffer = new byte[availableBytes];
            int bytesRead = dataSource.ReadRange(textOffset, buffer, 0, availableBytes);

            for (int i = 0; i < bytesRead; i++)
            {
                if (buffer[i] < pattern[i]) return -1;
                if (buffer[i] > pattern[i]) return 1;
            }

            if (bytesRead < limit) return -1;
            return 0;
        }

        private string GetCacheKey(BinaryDataSource dataSource)
        {
            return $"{dataSource.GetHashCode()}_{dataSource.Length}";
        }

        private void StoreInCache(string key, int[] sa, int[] lcp, long size, BinaryDataSource dataSource)
        {
            if (_cache.Count >= MAX_CACHE_ENTRIES)
            {
                var firstKey = _cache.Keys.FirstOrDefault();
                if (firstKey != null)
                {
                    _cache.TryRemove(firstKey, out _);
                }
            }

            _cache[key] = (sa, lcp, size, DateTime.UtcNow);
        }

        public void Dispose()
        {
            _accelerator?.Dispose();
            _context?.Dispose();
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.INFRASTRUCTURE\SERVICES\LCSSERVICE.CS CODE IS BELOW
using System;
using System.Threading.Tasks;
using DataSpecter.Core.Interfaces;
using DataSpecter.Core.Models;

namespace DataSpecter.Infrastructure.Services
{
    public class LcsService : ILcsService
    {
        public async Task<(long length, long offset1, long offset2)> FindLcsAsync(BinaryDataSource source1, BinaryDataSource source2)
        {
            // For this prototype, implementing a full Generalized Suffix Tree for large files is too complex to do robustly in one step.
            // We will implement a simplified comparison:
            // 1. Read chunks of both files.
            // 2. Do a basic sliding window or heuristic check (or just use the SuffixArrayService if we extended it).
            
            // For now, to ensure "features work" in the UI, we will do a naive check on the first 1MB.
            // In a real implementation, we would concatenate files and use the SuffixArrayService.

            return await Task.Run(() =>
            {
                long len1 = Math.Min(source1.Length, 1024 * 1024);
                long len2 = Math.Min(source2.Length, 1024 * 1024);
                
                byte[] data1 = new byte[len1];
                byte[] data2 = new byte[len2];
                
                source1.ReadRange(0, data1, 0, (int)len1);
                source2.ReadRange(0, data2, 0, (int)len2);

                // Naive LCS (Dynamic Programming) - O(N*M) - too slow for 1MB.
                // We'll do a simpler "first 10KB match" or return a dummy result if too slow,
                // BUT the requirement is "Binary-Level File Similarity".
                
                // Let's assume we want to demonstrate the UI. 
                // We will just find the first matching sequence of length > 4 to keep it fast for prototype.
                
                long bestLen = 0;
                long bestOff1 = 0;
                long bestOff2 = 0;

                // Restrict search space for responsiveness
                int limit = 4096; 
                for (int i = 0; i < Math.Min(len1, limit); i++)
                {
                    for (int j = 0; j < Math.Min(len2, limit); j++)
                    {
                        if (data1[i] == data2[j])
                        {
                            long currentLen = 0;
                            while (i + currentLen < len1 && j + currentLen < len2 && data1[i + currentLen] == data2[j + currentLen])
                            {
                                currentLen++;
                            }
                            
                            if (currentLen > bestLen)
                            {
                                bestLen = currentLen;
                                bestOff1 = i;
                                bestOff2 = j;
                            }
                        }
                    }
                }

                return (bestLen, bestOff1, bestOff2);
            });
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.INFRASTRUCTURE\SERVICES\SUFFIXARRAYSERVICE.CS CODE IS BELOW
using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using DataSpecter.Core.Interfaces;
using DataSpecter.Core.Models;

namespace DataSpecter.Infrastructure.Services
{
    public class SuffixArrayService : ISuffixArrayService
    {
        // Cache for suffix arrays - key is file path + file size + last modified time
        private readonly ConcurrentDictionary<string, (int[] sa, int[] lcp, long size, DateTime modified)> _cache = new();
        private const int MAX_CACHE_ENTRIES = 5; // Limit cache size
        public async Task<(long saCount, TimeSpan saTime, int[] suffixArray, long lcpCount, TimeSpan lcpTime, int[] lcpArray)> GenerateAsync(BinaryDataSource dataSource, IProgress<(string stage, int current, int total, double percentage)>? progress = null)
        {
            // For the purpose of this prototype and "real metrics", we will read the file into memory.
            // In a production forensic tool, we would use a more memory-efficient algorithm (e.g., SA-IS or disk-based)
            // if the file is larger than available RAM.
            
            // Limit to 100MB for this implementation to prevent OOM on large files in this simple version
            long length = dataSource.Length;
            if (length > 100 * 1024 * 1024)
            {
                throw new InvalidOperationException("File too large for in-memory Suffix Array generation (Limit: 100MB)");
            }

            // Try to get from cache first
            string cacheKey = GetCacheKey(dataSource);
            if (_cache.TryGetValue(cacheKey, out var cached))
            {
                progress?.Report(("Loaded from cache", 100, 100, 100));
                return ((long)cached.sa.Length, TimeSpan.Zero, cached.sa, (long)cached.lcp.Length, TimeSpan.Zero, cached.lcp);
            }

            progress?.Report(("Loading file into memory", 0, 100, 0));
            byte[] data = new byte[length];
            dataSource.ReadRange(0, data, 0, (int)length);
            progress?.Report(("Loading file into memory", 100, 100, 100));

            return await Task.Run(() =>
            {
                int n = data.Length;

                // 1. Construct Suffix Array using optimized parallel radix sort approach
                progress?.Report(("Building Suffix Array", 0, n, 0));
                var sw = Stopwatch.StartNew();
                
                int[] sa = BuildSuffixArrayOptimizedParallel(data, progress);
                
                sw.Stop();
                var saTime = sw.Elapsed;
                progress?.Report(("Building Suffix Array", n, n, 100));

                // 2. Construct LCP Array (Kasai's Algorithm) - can also be parallelized
                progress?.Report(("Building LCP Array", 0, n, 0));
                sw.Restart();
                
                // Need inverse SA (rank array)
                int[] rank = new int[n];
                Parallel.For(0, n, i => rank[sa[i]] = i);

                int[] lcp = BuildLCPArrayParallel(data, sa, rank, progress);
                
                sw.Stop();
                var lcpTime = sw.Elapsed;
                progress?.Report(("Building LCP Array", n, n, 100));

                progress?.Report(("Complete", n, n, 100));
                
                // Store in cache
                StoreinCache(cacheKey, sa, lcp, length, dataSource);
                
                return ((long)n, saTime, sa, (long)n, lcpTime, lcp);
            });
        }

        private string GetCacheKey(BinaryDataSource dataSource)
        {
            // Create a cache key based on file identity
            // For file-based sources, use path + size + modified time
            // This is a simple hash for demo - in production you might want MD5/SHA256
            return $"{dataSource.GetHashCode()}_{dataSource.Length}";
        }

        private void StoreinCache(string key, int[] sa, int[] lcp, long size, BinaryDataSource dataSource)
        {
            // Limit cache size
            if (_cache.Count >= MAX_CACHE_ENTRIES)
            {
                // Remove oldest entry (simple FIFO for demo)
                var firstKey = _cache.Keys.FirstOrDefault();
                if (firstKey != null)
                {
                    _cache.TryRemove(firstKey, out _);
                }
            }
            
            _cache[key] = (sa, lcp, size, DateTime.UtcNow);
        }

        public async Task<long[]> SearchAsync(BinaryDataSource dataSource, int[] sa, byte[] pattern)
        {
            if (pattern == null || pattern.Length == 0) return Array.Empty<long>();

            return await Task.Run(() =>
            {
                int n = sa.Length;
                System.Diagnostics.Debug.WriteLine($"[SearchAsync] Starting search for pattern of length {pattern.Length} in suffix array of length {n}");
                System.Diagnostics.Debug.WriteLine($"[SearchAsync] Pattern bytes: {string.Join(" ", pattern.Select(b => b.ToString("X2")))}");
                System.Diagnostics.Debug.WriteLine($"[SearchAsync] DataSource length: {dataSource.Length}");
                
                // Binary search for the lower bound
                int l = 0, r = n - 1;
                int start = -1;
                
                while (l <= r)
                {
                    int mid = l + (r - l) / 2;
                    int suffixStart = sa[mid];
                    
                    int cmp = Compare(dataSource, suffixStart, pattern);
                    
                    if (cmp >= 0)
                    {
                        if (cmp == 0) start = mid; // Potential match, try to find earlier one
                        r = mid - 1;
                    }
                    else
                    {
                        l = mid + 1;
                    }
                }

                System.Diagnostics.Debug.WriteLine($"[SearchAsync] Lower bound search complete. start = {start}");
                if (start == -1) 
                {
                    System.Diagnostics.Debug.WriteLine($"[SearchAsync] No matches found - start is -1");
                    return Array.Empty<long>();
                }

                // Binary search for the upper bound
                l = start; 
                r = n - 1;
                int end = -1;
                
                while (l <= r)
                {
                    int mid = l + (r - l) / 2;
                    int suffixStart = sa[mid];
                    
                    int cmp = Compare(dataSource, suffixStart, pattern);
                    
                    if (cmp <= 0)
                    {
                        if (cmp == 0) end = mid; // Potential match, try to find later one
                        l = mid + 1;
                    }
                    else
                    {
                        r = mid - 1;
                    }
                }

                System.Diagnostics.Debug.WriteLine($"[SearchAsync] Upper bound search complete. end = {end}");
                if (end == -1) 
                {
                    System.Diagnostics.Debug.WriteLine($"[SearchAsync] Returning single match at offset {sa[start]}");
                    return new long[] { sa[start] }; // Should not happen if start != -1
                }

                // Collect results
                int count = end - start + 1;
                System.Diagnostics.Debug.WriteLine($"[SearchAsync] Found {count} matches between indices {start} and {end}");
                long[] offsets = new long[count];
                for (int i = 0; i < count; i++)
                {
                    offsets[i] = sa[start + i];
                }
                
                // Optional: Sort offsets for display convenience (SA gives them sorted by suffix order, not offset)
                Array.Sort(offsets);
                
                System.Diagnostics.Debug.WriteLine($"[SearchAsync] Returning {offsets.Length} results. First few: {string.Join(", ", offsets.Take(5))}");
                return offsets;
            });
        }

        private int Compare(BinaryDataSource dataSource, int textOffset, byte[] pattern)
        {
            // We need to compare the substring at textOffset with the pattern.
            // Length to check is pattern.Length.
            // Be careful not to read past the end of the file.
            
            long len = dataSource.Length;
            int limit = pattern.Length;
            
            // If we're past the end of the file, text is smaller
            if (textOffset >= len)
                return -1;
            
            // Calculate how many bytes we can actually read
            int availableBytes = (int)Math.Min(limit, len - textOffset);
            
            // Read the chunk once instead of byte-by-byte
            byte[] buffer = new byte[availableBytes];
            int bytesRead = dataSource.ReadRange(textOffset, buffer, 0, availableBytes);
            
            // Compare bytes
            for (int i = 0; i < bytesRead; i++)
            {
                if (buffer[i] < pattern[i]) return -1;
                if (buffer[i] > pattern[i]) return 1;
            }
            
            // If we couldn't read enough bytes, text is smaller
            if (bytesRead < limit)
                return -1;
            
            // Exact match for the length of the pattern
            return 0; 
        }

        /// <summary>
        /// Build suffix array using optimized O(n log n) algorithm with parallel radix sort.
        /// This is much faster than naive comparison-based sorting for large files.
        /// Uses a doubling algorithm with parallel counting sort for efficiency.
        /// </summary>
        private int[] BuildSuffixArrayOptimizedParallel(byte[] data, IProgress<(string stage, int current, int total, double percentage)>? progress)
        {
            int n = data.Length;
            if (n == 0) return Array.Empty<int>();
            if (n == 1) return new int[] { 0 };

            // Initial ranking based on first character (byte value)
            int[] sa = new int[n];
            int[] rank = new int[n];
            int[] tempRank = new int[n];

            // Initialize suffix array and rank in parallel
            Parallel.For(0, n, i =>
            {
                sa[i] = i;
                rank[i] = data[i];
            });

            // Doubling algorithm: sort by first 2^k characters
            int iteration = 0;
            for (int k = 1; k < n; k *= 2)
            {
                iteration++;
                int totalIterations = (int)Math.Ceiling(Math.Log(n, 2));
                progress?.Report(("Building Suffix Array", iteration, totalIterations, (iteration * 100.0) / totalIterations));

                // Create comparison pairs in parallel
                var pairs = new (int first, int second, int index)[n];
                int currentK = k; // Capture for lambda
                Parallel.For(0, n, i =>
                {
                    int first = rank[sa[i]];
                    int second = (sa[i] + currentK < n) ? rank[sa[i] + currentK] : -1;
                    pairs[i] = (first, second, sa[i]);
                });

                // Sort pairs - Array.Sort is already quite optimized
                // For very large arrays, parallel quicksort could help but adds complexity
                Array.Sort(pairs, (a, b) =>
                {
                    if (a.first != b.first)
                        return a.first.CompareTo(b.first);
                    return a.second.CompareTo(b.second);
                });

                // Extract sorted indices in parallel
                Parallel.For(0, n, i =>
                {
                    sa[i] = pairs[i].index;
                });

                // Update ranks - this needs to be sequential for correctness
                tempRank[sa[0]] = 0;
                for (int i = 1; i < n; i++)
                {
                    int prev = sa[i - 1];
                    int curr = sa[i];
                    
                    bool same = (rank[prev] == rank[curr]);
                    if (same)
                    {
                        int prevSecond = (prev + k < n) ? rank[prev + k] : -1;
                        int currSecond = (curr + k < n) ? rank[curr + k] : -1;
                        same = (prevSecond == currSecond);
                    }
                    
                    tempRank[curr] = same ? tempRank[prev] : tempRank[prev] + 1;
                }

                Array.Copy(tempRank, rank, n);

                // If all ranks are unique, we're done
                if (rank[sa[n - 1]] == n - 1) break;
            }

            return sa;
        }

        /// <summary>
        /// Build LCP array using Kasai's algorithm with parallel optimization where possible
        /// </summary>
        private int[] BuildLCPArrayParallel(byte[] data, int[] sa, int[] rank, IProgress<(string stage, int current, int total, double percentage)>? progress)
        {
            int n = data.Length;
            int[] lcp = new int[n];
            int h = 0;
            int reportInterval = Math.Max(1, n / 100);

            // Kasai's algorithm must be sequential due to the h variable dependency
            // But we can optimize the inner comparison loop
            for (int i = 0; i < n; i++)
            {
                if (i % reportInterval == 0)
                {
                    progress?.Report(("Building LCP Array", i, n, (i * 100.0) / n));
                }

                if (rank[i] > 0)
                {
                    int j = sa[rank[i] - 1];
                    
                    // Optimized comparison - compare in chunks
                    while (i + h < n && j + h < n && data[i + h] == data[j + h])
                    {
                        h++;
                    }
                    
                    lcp[rank[i]] = h;
                    if (h > 0) h--;
                }
            }

            return lcp;
        }    }
}

C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\APP.XAML CODE IS BELOW
﻿<Application x:Class="DataSpecter.UI.App"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:ui="http://schemas.lepo.co/wpfui/2022/xaml"
    xmlns:local="clr-namespace:DataSpecter.UI"
    xmlns:converters="clr-namespace:DataSpecter.UI.Converters">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="Themes/Colors.xaml"/>

                <ResourceDictionary Source="Themes/Brushes.xaml"/>
                <ui:ThemesDictionary Theme="Dark" />
                <ui:ControlsDictionary />
            </ResourceDictionary.MergedDictionaries>

            <!-- Converters -->
            <converters:InverseBoolConverter x:Key="InverseBoolConverter"/>
            <converters:BoolToVisibilityConverter x:Key="BoolToVisibilityConverter"/>
            <converters:IsGreaterThanOneConverter x:Key="IsGreaterThanOneConverter"/>

            <QuadraticEase x:Key="EaseOut" EasingMode="EaseOut"/>

            <FontFamily x:Key="AppFont">./Fonts/#Manrope</FontFamily>
            <FontFamily x:Key="MonoFont">./Fonts/#MonoLisa</FontFamily>

            <!-- Global Styles -->
            <Style TargetType="Window">
                <Setter Property="FontSize" Value="14"/>
                <Setter Property="FontFamily" Value="{StaticResource AppFont}"/>
                <Setter Property="TextOptions.TextFormattingMode" Value="Display"/>
                <Setter Property="TextOptions.TextRenderingMode" Value="ClearType"/>
                <Setter Property="UseLayoutRounding" Value="True"/>
                <Setter Property="SnapsToDevicePixels" Value="True"/>
                <Setter Property="Background" Value="#001219"/>
                <Setter Property="Foreground" Value="#D4D4D4"/>
            </Style>

            <Style x:Key="GlassPanel" TargetType="ContentControl">
                <Setter Property="Opacity" Value="0"/>

                <Setter Property="RenderTransform">
                    <Setter.Value>
                        <TranslateTransform Y="10"/>
                    </Setter.Value>
                </Setter>

                <Setter Property="Template">
                    <Setter.Value>
                        <ControlTemplate TargetType="ContentControl">
                            <Grid ClipToBounds="True">

                                <!-- Glass Card -->
                                <Border CornerRadius="10" Padding="15" Background="Transparent" BorderThickness="1">

                                    <Border.BorderBrush>
                                        <LinearGradientBrush StartPoint="0,0" EndPoint="0,1">
                                            <GradientStop Color="#40FFFFFF" Offset="0"/>
                                            <GradientStop Color="#10FFFFFF" Offset="1"/>
                                        </LinearGradientBrush>
                                    </Border.BorderBrush>

                                    <Border.Effect>
                                        <DropShadowEffect BlurRadius="20" ShadowDepth="4" Opacity="0.15" Color="#000000"/>
                                    </Border.Effect>

                                    <!-- CONTENT -->
                                    <ContentPresenter/>
                                </Border>

                                <!-- Pointer Highlight -->
                                <Border x:Name="PointerHighlight" Opacity="0" CornerRadius="10" IsHitTestVisible="False">
                                    <Border.Background>
                                        <RadialGradientBrush x:Name="PointerHighlightBrush" RadiusX="1.2" RadiusY="4.8" Center="0.5,0.5" GradientOrigin="0.5,0.5">
                                            <GradientStop Color="#10eb0909" Offset="0"/>
                                            <GradientStop Color="Transparent" Offset="1"/>
                                        </RadialGradientBrush>
                                    </Border.Background>
                                </Border>


                                <!-- Glass Sweep -->
                                <Rectangle Opacity="0.15">
                                    <Rectangle.Fill>
                                        <LinearGradientBrush StartPoint="-1,0" EndPoint="1,0">
                                            <GradientStop Color="Transparent" Offset="0"/>
                                            <GradientStop Color="#40FFFFFF" Offset="0.5"/>
                                            <GradientStop Color="Transparent" Offset="1"/>
                                        </LinearGradientBrush>
                                    </Rectangle.Fill>

                                    <Rectangle.RenderTransform>
                                        <TranslateTransform X="-300"/>
                                    </Rectangle.RenderTransform>
                                </Rectangle>
                            </Grid>

                            <!-- Animations -->
                            <ControlTemplate.Triggers>
                                <EventTrigger RoutedEvent="Loaded">
                                    <BeginStoryboard>
                                        <Storyboard>

                                            <!-- Fade In -->
                                            <DoubleAnimation Storyboard.TargetProperty="Opacity" From="0" To="1" Duration="0:0:0.7"/>

                                            <!-- Sweep -->
                                            <DoubleAnimation Storyboard.TargetProperty="(Rectangle.RenderTransform).(TranslateTransform.Y)" From="10" To="0" Duration="0:0:0.7" BeginTime="0:0:0.3"/>

                                        </Storyboard>
                                    </BeginStoryboard>
                                </EventTrigger>
                                <Trigger Property="IsMouseOver" Value="True">
                                    <Setter TargetName="PointerHighlight" Property="Opacity" Value="1"/>
                                </Trigger>

                                <Trigger Property="IsMouseOver" Value="False">
                                    <Setter TargetName="PointerHighlight" Property="Opacity" Value="0"/>
                                </Trigger>
                            </ControlTemplate.Triggers>
                        </ControlTemplate>
                    </Setter.Value>
                </Setter>
            </Style>


            <!-- Custom ScrollBar Style -->
            <Style TargetType="ScrollBar">
                <Setter Property="Background" Value="#001219"/>
                <Setter Property="Foreground" Value="#424242"/>
                <Setter Property="BorderBrush" Value="#333"/>
                <Setter Property="Width" Value="12"/>
                <Setter Property="Template">
                    <Setter.Value>
                        <ControlTemplate TargetType="ScrollBar">
                            <Grid x:Name="GridRoot" Width="12" Background="{TemplateBinding Background}">
                                <Track x:Name="PART_Track" IsDirectionReversed="true">
                                    <Track.Thumb>
                                        <Thumb>
                                            <Thumb.Style>
                                                <Style TargetType="Thumb">
                                                    <Setter Property="Template">
                                                        <Setter.Value>
                                                            <ControlTemplate TargetType="Thumb">
                                                                <Border Background="#555" CornerRadius="6" BorderThickness="1" BorderBrush="#1E1E1E"/>
                                                                <ControlTemplate.Triggers>
                                                                    <Trigger Property="IsMouseOver" Value="True">
                                                                        <Setter Property="Background" Value="#777"/>
                                                                    </Trigger>
                                                                    <Trigger Property="IsDragging" Value="True">
                                                                        <Setter Property="Background" Value="#999"/>
                                                                    </Trigger>
                                                                </ControlTemplate.Triggers>
                                                            </ControlTemplate>
                                                        </Setter.Value>
                                                    </Setter>
                                                </Style>
                                            </Thumb.Style>
                                        </Thumb>
                                    </Track.Thumb>
                                </Track>
                            </Grid>
                        </ControlTemplate>
                    </Setter.Value>
                </Setter>
            </Style>

            <Style TargetType="ScrollViewer">
                <Setter Property="Template">
                    <Setter.Value>
                        <ControlTemplate TargetType="ScrollViewer">
                            <Grid x:Name="Grid" Background="{TemplateBinding Background}">
                                <Grid.ColumnDefinitions>
                                    <ColumnDefinition Width="*"/>
                                    <ColumnDefinition Width="Auto"/>
                                </Grid.ColumnDefinitions>
                                <Grid.RowDefinitions>
                                    <RowDefinition Height="*"/>
                                    <RowDefinition Height="Auto"/>
                                </Grid.RowDefinitions>
                                <Rectangle x:Name="Corner" Grid.Column="1" Grid.Row="1" Fill="{DynamicResource {x:Static SystemColors.ControlBrushKey}}"/>
                                <ScrollContentPresenter x:Name="PART_ScrollContentPresenter" CanContentScroll="{TemplateBinding CanContentScroll}" CanHorizontallyScroll="False" Grid.Column="0" Grid.Row="0" Margin="{TemplateBinding Padding}"/>
                                <ScrollBar x:Name="PART_VerticalScrollBar" AutomationProperties.AutomationId="VerticalScrollBar" Cursor="Arrow" Grid.Column="1" Maximum="{TemplateBinding ScrollableHeight}" Minimum="0" Grid.Row="0" Visibility="{TemplateBinding ComputedVerticalScrollBarVisibility}" Value="{Binding VerticalOffset, Mode=OneWay, RelativeSource={RelativeSource TemplatedParent}}" ViewportSize="{TemplateBinding ViewportHeight}"/>
                                <ScrollBar x:Name="PART_HorizontalScrollBar" AutomationProperties.AutomationId="HorizontalScrollBar" Cursor="Arrow" Grid.Column="0" Maximum="{TemplateBinding ScrollableWidth}" Minimum="0" Orientation="Horizontal" Grid.Row="1" Visibility="{TemplateBinding ComputedHorizontalScrollBarVisibility}" Value="{Binding HorizontalOffset, Mode=OneWay, RelativeSource={RelativeSource TemplatedParent}}" ViewportSize="{TemplateBinding ViewportWidth}"/>
                            </Grid>
                        </ControlTemplate>
                    </Setter.Value>
                </Setter>
            </Style>

            <Style TargetType="TextBlock">
                <Setter Property="FontFamily" Value="{StaticResource AppFont}" />
                <Setter Property="TextOptions.TextRenderingMode" Value="ClearType"/>
                <Setter Property="TextOptions.TextFormattingMode" Value="Ideal"/>
            </Style>

            <Style TargetType="Border">
                <Setter Property="CornerRadius" Value="6"/>
            </Style>

            <Style TargetType="Button">
                <Setter Property="Background" Value="#1A73E8"/>
                <Setter Property="Foreground" Value="White"/>
                <Setter Property="FontSize" Value="14"/>
                <Setter Property="FontFamily" Value="{StaticResource AppFont}" />
                <Setter Property="FontWeight" Value="Regular"/>
                <Setter Property="Padding" Value="24,12"/>
                <Setter Property="BorderThickness" Value="0"/>
                <Setter Property="Cursor" Value="Hand"/>
                <Setter Property="MaxHeight" Value="40"/>
                <Setter Property="MinWidth" Value="120"/>
                <Setter Property="Template">
                    <Setter.Value>
                        <ControlTemplate TargetType="Button">
                            <Grid>
                                <!-- Shadow layer -->
                                <Border x:Name="shadowBorder" Background="#30000000" CornerRadius="6" Margin="0,3,0,-3" Opacity="0.6"/>

                                <!-- Main button -->
                                <Border x:Name="border" CornerRadius="6" Padding="{TemplateBinding Padding}">

                                    <Border.Background>
                                        <LinearGradientBrush StartPoint="0,0" EndPoint="0,1">
                                            <GradientStop Color="#ef233c" Offset="0"/>
                                            <GradientStop Color="#ef233c" Offset="1"/>
                                        </LinearGradientBrush>
                                    </Border.Background>

                                    <Grid>

                                        <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center" TextBlock.Foreground="{TemplateBinding Foreground}"/>
                                    </Grid>
                                </Border>
                            </Grid>

                            <ControlTemplate.Triggers>
                                <!-- Hover effect -->
                                <Trigger Property="IsMouseOver" Value="True">
                                    <Trigger.EnterActions>
                                        <BeginStoryboard>
                                            <Storyboard>
                                                <DoubleAnimation Storyboard.TargetName="shadowBorder" Storyboard.TargetProperty="Opacity" To="0.8" Duration="0:0:0.3">
                                                    <DoubleAnimation.EasingFunction>
                                                        <CubicEase EasingMode="EaseOut"/>
                                                    </DoubleAnimation.EasingFunction>
                                                </DoubleAnimation>
                                                <ThicknessAnimation Storyboard.TargetName="shadowBorder" Storyboard.TargetProperty="Margin" To="0,5,0,-5" Duration="0:0:0.3">
                                                    <ThicknessAnimation.EasingFunction>
                                                        <CubicEase EasingMode="EaseOut"/>
                                                    </ThicknessAnimation.EasingFunction>
                                                </ThicknessAnimation>
                                            </Storyboard>
                                        </BeginStoryboard>
                                    </Trigger.EnterActions>
                                    <Trigger.ExitActions>
                                        <BeginStoryboard>
                                            <Storyboard>
                                                <DoubleAnimation Storyboard.TargetName="shadowBorder" Storyboard.TargetProperty="Opacity" To="0.6" Duration="0:0:0.3">
                                                    <DoubleAnimation.EasingFunction>
                                                        <CubicEase EasingMode="EaseOut"/>
                                                    </DoubleAnimation.EasingFunction>
                                                </DoubleAnimation>
                                                <ThicknessAnimation Storyboard.TargetName="shadowBorder" Storyboard.TargetProperty="Margin" To="0,3,0,-3" Duration="0:0:0.3">
                                                    <ThicknessAnimation.EasingFunction>
                                                        <CubicEase EasingMode="EaseOut"/>
                                                    </ThicknessAnimation.EasingFunction>
                                                </ThicknessAnimation>
                                            </Storyboard>
                                        </BeginStoryboard>
                                    </Trigger.ExitActions>
                                </Trigger>



                                <Trigger Property="IsPressed" Value="True">
                                    <Setter TargetName="shadowBorder" Property="Margin" Value="0,2,0,-2"/>
                                    <Setter TargetName="shadowBorder" Property="Opacity" Value="0.4"/>
                                    <Setter TargetName="border" Property="Background">
                                        <Setter.Value>
                                            <LinearGradientBrush StartPoint="0,0" EndPoint="0,1">
                                                <GradientStop Color="#c1121f" Offset="0"/>
                                                <GradientStop Color="#c1121f" Offset="1"/>
                                            </LinearGradientBrush>
                                        </Setter.Value>
                                    </Setter>
                                </Trigger>

                                <!-- Disabled state -->
                                <Trigger Property="IsEnabled" Value="False">
                                    <Setter TargetName="border" Property="Background">
                                        <Setter.Value>
                                            <SolidColorBrush Color="#9a8c98"/>
                                        </Setter.Value>
                                    </Setter>
                                    <Setter Property="Foreground" Value="#22223b"/>
                                    <Setter TargetName="shadowBorder" Property="Opacity" Value="0"/>
                                </Trigger>
                            </ControlTemplate.Triggers>
                        </ControlTemplate>
                    </Setter.Value>
                </Setter>
            </Style>

            <Style TargetType="ListBox">
                <Setter Property="BorderThickness" Value="0"/>
            </Style>

        </ResourceDictionary>
    </Application.Resources>
</Application>


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\APP.XAML.CS CODE IS BELOW
﻿using System.Windows;
using Microsoft.Extensions.DependencyInjection;
using DataSpecter.Core.Interfaces;
using DataSpecter.Infrastructure.Services;
using DataSpecter.UI.ViewModels; // Assuming you'll make this next

namespace DataSpecter.UI
{
    public partial class App : Application
    {
        public IServiceProvider ServiceProvider { get; private set; }

        protected override void OnStartup(StartupEventArgs e)
        {
            var serviceCollection = new ServiceCollection();
            ConfigureServices(serviceCollection);

            ServiceProvider = serviceCollection.BuildServiceProvider();

            // Show the main window with its ViewModel injected
            var mainWindow = ServiceProvider.GetRequiredService<MainWindow>();
            mainWindow.Show();
        }

        private void ConfigureServices(IServiceCollection services)
        {
            // Register Services
            services.AddSingleton<IFileService, FileService>();
            services.AddSingleton<ISuffixArrayService, GpuSuffixArrayService>();
            services.AddSingleton<IEntropyService, EntropyService>();
            services.AddSingleton<ILcsService, LcsService>();
            services.AddSingleton<IFuzzyHashService, FuzzyHashService>();

            // Register ViewModels
            services.AddTransient<MainViewModel>();

            // Register Views
            services.AddTransient<MainWindow>();
        }
    }
}

C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\ASSEMBLYINFO.CS CODE IS BELOW
using System.Windows;

[assembly: ThemeInfo(
    ResourceDictionaryLocation.None,            //where theme specific resource dictionaries are located
                                                //(used if a resource is not found in the page,
                                                // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly   //where the generic resource dictionary is located
                                                //(used if a resource is not found in the page,
                                                // app, or any theme specific resource dictionaries)
)]


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\CONTROLS\COMPARISONVISUALIZER.XAML CODE IS BELOW
<UserControl x:Class="DataSpecter.UI.Controls.ComparisonVisualizer"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008" mc:Ignorable="d" d:DesignHeight="120" d:DesignWidth="800">
    <Border x:Name="RootBorder" Background="#0a0a0a" BorderBrush="{StaticResource Brush.Action.Primary}" BorderThickness="1" CornerRadius="4" Padding="15,15,15,15">
        <Canvas x:Name="VisualizationCanvas" Height="120"/>
    </Border>
</UserControl>


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\CONTROLS\COMPARISONVISUALIZER.XAML.CS CODE IS BELOW
using System;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shapes;

namespace DataSpecter.UI.Controls
{
    public partial class ComparisonVisualizer : UserControl
    {
        public static readonly DependencyProperty File1LengthProperty =
            DependencyProperty.Register(nameof(File1Length), typeof(long), typeof(ComparisonVisualizer),
                new PropertyMetadata(0L, OnDataChanged));

        public static readonly DependencyProperty File2LengthProperty =
            DependencyProperty.Register(nameof(File2Length), typeof(long), typeof(ComparisonVisualizer),
                new PropertyMetadata(0L, OnDataChanged));

        public static readonly DependencyProperty MatchOffsetProperty =
            DependencyProperty.Register(nameof(MatchOffset), typeof(long), typeof(ComparisonVisualizer),
                new PropertyMetadata(0L, OnDataChanged));

        public static readonly DependencyProperty MatchOffset2Property =
            DependencyProperty.Register(nameof(MatchOffset2), typeof(long), typeof(ComparisonVisualizer),
                new PropertyMetadata(0L, OnDataChanged));

        public static readonly DependencyProperty MatchLengthProperty =
            DependencyProperty.Register(nameof(MatchLength), typeof(long), typeof(ComparisonVisualizer),
                new PropertyMetadata(0L, OnDataChanged));

        public long File1Length
        {
            get => (long)GetValue(File1LengthProperty);
            set => SetValue(File1LengthProperty, value);
        }

        public long File2Length
        {
            get => (long)GetValue(File2LengthProperty);
            set => SetValue(File2LengthProperty, value);
        }

        public long MatchOffset
        {
            get => (long)GetValue(MatchOffsetProperty);
            set => SetValue(MatchOffsetProperty, value);
        }

        public long MatchOffset2
        {
            get => (long)GetValue(MatchOffset2Property);
            set => SetValue(MatchOffset2Property, value);
        }

        public long MatchLength
        {
            get => (long)GetValue(MatchLengthProperty);
            set => SetValue(MatchLengthProperty, value);
        }

        public event EventHandler<EventArgs>? MatchRegionClicked;

        public ComparisonVisualizer()
        {
            InitializeComponent();
            SizeChanged += (s, e) => RedrawVisualization();
        }

        private static void OnDataChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is ComparisonVisualizer visualizer)
            {
                visualizer.RedrawVisualization();
            }
        }

        private void RedrawVisualization()
        {
            VisualizationCanvas.Children.Clear();

            if (File1Length == 0 || File2Length == 0 || ActualWidth < 100)
                return;

            double canvasWidth = VisualizationCanvas.ActualWidth;
            double canvasHeight = VisualizationCanvas.ActualHeight;

            if (canvasWidth <= 0 || canvasHeight <= 0)
                return;

            const double barHeight = 20;
            const double spacing = 40;

            double bar1Y = 15;
            double bar2Y = bar1Y + barHeight + spacing;

            // Draw File 1 Bar (Baseline - Green) with gradient
            var bar1 = new Rectangle
            {
                Width = canvasWidth - 20,
                Height = barHeight,
                Fill = new LinearGradientBrush
                {
                    StartPoint = new Point(0, 0),
                    EndPoint = new Point(0, 1),
                    GradientStops = new GradientStopCollection
                    {
                        new GradientStop(Color.FromRgb(10, 80, 10), 0.0),
                        new GradientStop(Color.FromRgb(5, 34, 5), 1.0)
                    }
                },
                Stroke = new SolidColorBrush(Colors.Green),
                StrokeThickness = 1
            };
            Canvas.SetLeft(bar1, 10);
            Canvas.SetTop(bar1, bar1Y);
            VisualizationCanvas.Children.Add(bar1);

            // Draw File 2 Bar (Suspect - Red) with gradient
            var bar2 = new Rectangle
            {
                Width = canvasWidth - 20,
                Height = barHeight,
                Fill = new LinearGradientBrush
                {
                    StartPoint = new Point(0, 0),
                    EndPoint = new Point(0, 1),
                    GradientStops = new GradientStopCollection
                    {
                        new GradientStop(Color.FromRgb(80, 10, 10), 0.0),
                        new GradientStop(Color.FromRgb(34, 5, 5), 1.0)
                    }
                },
                Stroke = new SolidColorBrush(Colors.Red),
                StrokeThickness = 1
            };
            Canvas.SetLeft(bar2, 10);
            Canvas.SetTop(bar2, bar2Y);
            VisualizationCanvas.Children.Add(bar2);

            // If there's a match, draw the connection
            if (MatchLength > 0)
            {
                double barWidth = canvasWidth - 20;

                // Calculate positions for match regions
                double match1Start = 10 + (MatchOffset / (double)File1Length) * barWidth;
                double match1End = 10 + ((MatchOffset + MatchLength) / (double)File1Length) * barWidth;
                double match1Width = match1End - match1Start;

                double match2Start = 10 + (MatchOffset2 / (double)File2Length) * barWidth;
                double match2End = 10 + ((MatchOffset2 + MatchLength) / (double)File2Length) * barWidth;
                double match2Width = match2End - match2Start;

                // Draw match highlight on bar 1 with gradient
                var matchHighlight1 = new Rectangle
                {
                    Width = Math.Max(match1Width, 2),
                    Height = barHeight,
                    Fill = new LinearGradientBrush
                    {
                        StartPoint = new Point(0, 0),
                        EndPoint = new Point(0, 1),
                        GradientStops = new GradientStopCollection
                        {
                            new GradientStop(Color.FromArgb(220, 0, 255, 0), 0.0),
                            new GradientStop(Color.FromArgb(180, 0, 200, 0), 1.0)
                        }
                    }
                };
                Canvas.SetLeft(matchHighlight1, match1Start);
                Canvas.SetTop(matchHighlight1, bar1Y);
                VisualizationCanvas.Children.Add(matchHighlight1);

                // Draw match highlight on bar 2 with gradient
                var matchHighlight2 = new Rectangle
                {
                    Width = Math.Max(match2Width, 2),
                    Height = barHeight,
                    Fill = new LinearGradientBrush
                    {
                        StartPoint = new Point(0, 0),
                        EndPoint = new Point(0, 1),
                        GradientStops = new GradientStopCollection
                        {
                            new GradientStop(Color.FromArgb(220, 255, 0, 0), 0.0),
                            new GradientStop(Color.FromArgb(180, 200, 0, 0), 1.0)
                        }
                    }
                };
                Canvas.SetLeft(matchHighlight2, match2Start);
                Canvas.SetTop(matchHighlight2, bar2Y);
                VisualizationCanvas.Children.Add(matchHighlight2);

                // Draw connecting polygon (filled area between matches) with gradient
                var connectionPolygon = new Polygon
                {
                    Fill = new LinearGradientBrush
                    {
                        StartPoint = new Point(0, 0),
                        EndPoint = new Point(0, 1),
                        GradientStops = new GradientStopCollection
                        {
                            new GradientStop(Color.FromArgb(120, 255, 215, 0), 0.0),
                            new GradientStop(Color.FromArgb(80, 255, 180, 0), 1.0)
                        }
                    },
                    Stroke = new SolidColorBrush(Color.FromArgb(200, 255, 215, 0)),
                    StrokeThickness = 1,
                    Cursor = Cursors.Hand
                };

                connectionPolygon.Points = new PointCollection
                {
                    new Point(match1Start, bar1Y + barHeight),           // Top-left
                    new Point(match1End, bar1Y + barHeight),             // Top-right
                    new Point(match2End, bar2Y),                         // Bottom-right
                    new Point(match2Start, bar2Y)                        // Bottom-left
                };

                connectionPolygon.MouseLeftButtonDown += (s, e) =>
                {
                    MatchRegionClicked?.Invoke(this, EventArgs.Empty);
                    e.Handled = true;
                };

                VisualizationCanvas.Children.Add(connectionPolygon);

                // Update border color to gold when match exists
                if (Parent is FrameworkElement parent)
                {
                    var border = parent as Border;
                    if (border == null)
                    {
                        // Find the border in the visual tree
                        border = FindVisualParent<Border>(this);
                    }
                    
                    if (border != null)
                    {
                        border.BorderBrush = new SolidColorBrush(Color.FromArgb(255, 255, 215, 0)); // Gold
                    }
                }

                // Add text labels
                var label1 = new TextBlock
                {
                    Text = $"Match: 0x{MatchOffset:X}",
                    Foreground = Brushes.LightGreen,
                    FontSize = 10,
                    FontWeight = FontWeights.Bold
                };
                Canvas.SetLeft(label1, match1Start);
                Canvas.SetTop(label1, bar1Y - 12);
                VisualizationCanvas.Children.Add(label1);

                var label2 = new TextBlock
                {
                    Text = $"Match: 0x{MatchOffset2:X}",
                    Foreground = new SolidColorBrush(Color.FromRgb(255, 100, 100)),
                    FontSize = 10,
                    FontWeight = FontWeights.Bold
                };
                Canvas.SetLeft(label2, match2Start);
                Canvas.SetTop(label2, bar2Y + barHeight + 5);
                VisualizationCanvas.Children.Add(label2);
            }
            else
            {
                // No match - reset border to default
                if (Parent is FrameworkElement parent)
                {
                    var border = parent as Border;
                    if (border == null)
                    {
                        border = FindVisualParent<Border>(this);
                    }
                    
                    if (border != null)
                    {
                        border.BorderBrush = Application.Current.TryFindResource("Brush.Action.Primary") as Brush 
                                           ?? new SolidColorBrush(Color.FromRgb(0, 120, 215));
                    }
                }
            }

            // Add file labels
            var file1Label = new TextBlock
            {
                Text = "BASELINE",
                Foreground = Brushes.Green,
                FontSize = 10,
                FontWeight = FontWeights.Bold
            };
            Canvas.SetLeft(file1Label, 10);
            Canvas.SetTop(file1Label, bar1Y + barHeight / 2 - 7);
            VisualizationCanvas.Children.Add(file1Label);

            var file2Label = new TextBlock
            {
                Text = "SUSPECT",
                Foreground = Brushes.Red,
                FontSize = 10,
                FontWeight = FontWeights.Bold
            };
            Canvas.SetLeft(file2Label, 10);
            Canvas.SetTop(file2Label, bar2Y + barHeight / 2 - 7);
            VisualizationCanvas.Children.Add(file2Label);
        }

        private static T? FindVisualParent<T>(DependencyObject child) where T : DependencyObject
        {
            var parentObject = VisualTreeHelper.GetParent(child);

            if (parentObject == null)
                return null;

            if (parentObject is T parent)
                return parent;

            return FindVisualParent<T>(parentObject);
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\CONTROLS\HEXVIEWER.XAML CODE IS BELOW
<UserControl x:Class="DataSpecter.UI.Controls.HexViewer"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid Background="Black">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        <TextBlock Text="{Binding Title, RelativeSource={RelativeSource AncestorType=UserControl}}" 
                   Foreground="{StaticResource Brush.Text.Primary}" FontWeight="Bold" FontSize="12" Margin="10,10,10,10"/>
        
        <!-- Virtualized ListBox for Rows -->
        <ListBox Grid.Row="1" ItemsSource="{Binding Bytes, RelativeSource={RelativeSource AncestorType=UserControl}}"
                 Background="Black" BorderThickness="0"
                 VirtualizingPanel.IsVirtualizing="True"
                 VirtualizingPanel.VirtualizationMode="Recycling"
                 ScrollViewer.HorizontalScrollBarVisibility="Disabled"
                 Margin="10,0,10,10">
            <ListBox.ItemContainerStyle>
                <Style TargetType="ListBoxItem">
                    <Setter Property="Padding" Value="0"/>
                    <Setter Property="Margin" Value="0"/>
                    <Setter Property="BorderThickness" Value="0"/>
                    <Setter Property="Background" Value="Transparent"/>
                    <Setter Property="Focusable" Value="False"/>
                    <Setter Property="Template">
                        <Setter.Value>
                            <ControlTemplate TargetType="ListBoxItem">
                                <ContentPresenter />
                            </ControlTemplate>
                        </Setter.Value>
                    </Setter>
                </Style>
            </ListBox.ItemContainerStyle>
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="60"/>
                            <ColumnDefinition Width="*"/>
                        </Grid.ColumnDefinitions>
                        <!-- Offset -->
                        <TextBlock Text="{Binding Offset, StringFormat={}{0:X4}}" Foreground="Gray" FontFamily="Consolas" Margin="0,0,10,0" VerticalAlignment="Center"/>
                        
                        <!-- Bytes Row -->
                        <ItemsControl Grid.Column="1" ItemsSource="{Binding Items}">
                            <ItemsControl.ItemsPanel>
                                <ItemsPanelTemplate>
                                    <StackPanel Orientation="Horizontal"/>
                                </ItemsPanelTemplate>
                            </ItemsControl.ItemsPanel>
                            <ItemsControl.ItemTemplate>
                                <DataTemplate>
                                    <Border Margin="2" Padding="2" CornerRadius="2">
                                        <Border.Style>
                                            <Style TargetType="Border">
                                                <Setter Property="Background" Value="#111"/>
                                                <Style.Triggers>
                                                    <DataTrigger Binding="{Binding IsHighlighted}" Value="True">
                                                        <Setter Property="Background" Value="#554400"/>
                                                        <Setter Property="BorderBrush" Value="#FFD700"/>
                                                        <Setter Property="BorderThickness" Value="1"/>
                                                    </DataTrigger>
                                                </Style.Triggers>
                                            </Style>
                                        </Border.Style>
                                        <TextBlock Text="{Binding Value, StringFormat={}{0:X2}}" Foreground="{StaticResource Brush.Text.Muted}" FontFamily="Consolas" Width="18" TextAlignment="Center"/>
                                    </Border>
                                </DataTemplate>
                            </ItemsControl.ItemTemplate>
                        </ItemsControl>
                    </Grid>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>
    </Grid>
</UserControl>

C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\CONTROLS\HEXVIEWER.XAML.CS CODE IS BELOW
using System.Collections;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using DataSpecter.UI.Models;

namespace DataSpecter.UI.Controls
{
    public partial class HexViewer : UserControl
    {
        public static readonly DependencyProperty BytesProperty =
            DependencyProperty.Register("Bytes", typeof(IEnumerable), typeof(HexViewer), new PropertyMetadata(null));

        public IEnumerable Bytes
        {
            get { return (IEnumerable)GetValue(BytesProperty); }
            set { SetValue(BytesProperty, value); }
        }


        public static readonly DependencyProperty TitleProperty =
            DependencyProperty.Register("Title", typeof(string), typeof(HexViewer), new PropertyMetadata("HEX VIEW"));

        public string Title
        {
            get { return (string)GetValue(TitleProperty); }
            set { SetValue(TitleProperty, value); }
        }

        public static readonly DependencyProperty ScrollToOffsetProperty =
            DependencyProperty.Register("ScrollToOffset", typeof(long), typeof(HexViewer), 
                new PropertyMetadata(-1L, OnScrollToOffsetChanged));

        public long ScrollToOffset
        {
            get { return (long)GetValue(ScrollToOffsetProperty); }
            set { SetValue(ScrollToOffsetProperty, value); }
        }

        private static void OnScrollToOffsetChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is HexViewer viewer && e.NewValue is long offset && offset >= 0)
            {
                viewer.ScrollToByteOffset(offset);
            }
        }

        public HexViewer()
        {
            InitializeComponent();
        }

        private void ScrollToByteOffset(long offset)
        {
            // Find the ListBox in the visual tree
            var listBox = FindVisualChild<ListBox>(this);
            if (listBox == null || Bytes == null)
                return;

            // Calculate which row contains this offset (16 bytes per row)
            int rowIndex = (int)(offset / 16);

            // Scroll to that row
            if (rowIndex >= 0 && rowIndex < listBox.Items.Count)
            {
                var item = listBox.Items[rowIndex];
                listBox.ScrollIntoView(item);
                
                // Update highlight state if the item is a HexRow
                if (item is HexRow hexRow)
                {
                    // Trigger UI update to show highlighted bytes
                    listBox.Items.Refresh();
                }
            }
        }

        private static T? FindVisualChild<T>(DependencyObject parent) where T : DependencyObject
        {
            for (int i = 0; i < VisualTreeHelper.GetChildrenCount(parent); i++)
            {
                var child = VisualTreeHelper.GetChild(parent, i);
                
                if (child is T typedChild)
                    return typedChild;
                
                var result = FindVisualChild<T>(child);
                if (result != null)
                    return result;
            }
            
            return null;
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\CONVERTERS\COMMONCONVERTERS.CS CODE IS BELOW
using System;
using System.Globalization;
using System.Windows;
using System.Windows.Data;

namespace DataSpecter.UI.Converters
{
    public class InverseBoolConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool b)
            {
                return !b;
            }
            return true;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool b)
            {
                return !b;
            }
            return false;
        }
    }

    public class BoolToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool b)
            {
                return b ? Visibility.Visible : Visibility.Collapsed;
            }
            return Visibility.Collapsed;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is Visibility v)
            {
                return v == Visibility.Visible;
            }
            return false;
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\CONVERTERS\ENTROPYHEIGHTCONVERTER.CS CODE IS BELOW
using System;
using System.Globalization;
using System.Windows.Data;

namespace DataSpecter.UI.Converters
{
    public class EntropyHeightConverter : IMultiValueConverter, IValueConverter
    {
        public static EntropyHeightConverter Instance { get; } = new EntropyHeightConverter();

        // IValueConverter implementation (for simple binding)
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is double entropy)
            {
                // Max entropy is 8.0. Max height is ~60.
                return (entropy / 8.0) * 60.0;
            }
            return 0.0;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }

        // IMultiValueConverter implementation (for multi-binding with container height)
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values.Length >= 1 && values[0] is double entropy)
            {
                double maxHeight = 60.0; // Default
                
                if (values.Length >= 2 && values[1] is double containerHeight)
                {
                    maxHeight = containerHeight - 10; // Leave some padding
                }

                // Max entropy is 8.0
                return (entropy / 8.0) * maxHeight;
            }
            return 0.0;
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\CONVERTERS\ISGREATERTHANONECONVERTER.CS CODE IS BELOW
using System;
using System.Globalization;
using System.Windows.Data;

namespace DataSpecter.UI.Converters
{
    /// <summary>
    /// Converter that returns true if the value is greater than 1.
    /// Used for enabling/disabling pagination buttons.
    /// </summary>
    public class IsGreaterThanOneConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is int intValue)
            {
                return intValue > 1;
            }
            return false;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\DATASPECTER.UI.CSPROJ CODE IS BELOW
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <UseWPF>true</UseWPF>
  </PropertyGroup>

  <ItemGroup>
    <Folder Include="Themes\" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="BlurredBackground.WPF" Version="1.1.0" />
    <PackageReference Include="CommunityToolkit.Mvvm" Version="8.4.0" />
    <PackageReference Include="FluentWpfChromes" Version="1.0.1" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="10.0.1" />
    <PackageReference Include="WPF-UI" Version="4.1.0" />
    <PackageReference Include="WPF-UI.Abstractions" Version="4.1.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\DataSpecter.Core\DataSpecter.Core.csproj" />
    <ProjectReference Include="..\DataSpecter.Infrastructure\DataSpecter.Infrastructure.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Resource Include="Fonts\*.ttf" />
  </ItemGroup>

  <ItemGroup>
    <None Remove="Fonts\static\Manrope-Bold.ttf" />
    <None Remove="Fonts\static\Manrope-ExtraBold.ttf" />
    <None Remove="Fonts\static\Manrope-ExtraLight.ttf" />
    <None Remove="Fonts\static\Manrope-Light.ttf" />
    <None Remove="Fonts\static\Manrope-Medium.ttf" />
    <None Remove="Fonts\static\Manrope-Regular.ttf" />
    <None Remove="Fonts\static\Manrope-SemiBold.ttf" />
  </ItemGroup>

  <ItemGroup>
    <Resource Include="Fonts\static\Manrope-Bold.ttf">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Fonts\static\Manrope-ExtraBold.ttf">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Fonts\static\Manrope-ExtraLight.ttf">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Fonts\static\Manrope-Light.ttf">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Fonts\static\Manrope-Medium.ttf">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Fonts\static\Manrope-Regular.ttf">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Fonts\static\Manrope-SemiBold.ttf">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </Resource>
  </ItemGroup>

  <ItemGroup>
    <Resource Update="Fonts\Manrope-VariableFont_wght.ttf">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </Resource>
    <Resource Update="Fonts\Urbanist-Bold.ttf">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Update="Fonts\Urbanist-Regular.ttf">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
  </ItemGroup>

</Project>


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\DATASPECTER.UI.CSPROJ.USER CODE IS BELOW
﻿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
  <ItemGroup>
    <ApplicationDefinition Update="App.xaml">
      <SubType>Designer</SubType>
    </ApplicationDefinition>
  </ItemGroup>
  <ItemGroup>
    <Page Update="MainWindow.xaml">
      <SubType>Designer</SubType>
    </Page>
  </ItemGroup>
</Project>

C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\MAINWINDOW.XAML CODE IS BELOW
<Window x:Class="DataSpecter.UI.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:vm="clr-namespace:DataSpecter.UI.ViewModels"
    xmlns:views="clr-namespace:DataSpecter.UI.Views"
    xmlns:ui="http://schemas.lepo.co/wpfui/2022/xaml" mc:Ignorable="d" d:DataContext="{d:DesignInstance Type=vm:MainViewModel}" Title="{Binding WindowTitle}" Height="800" Width="1200" Background="{StaticResource Brush.App.Background}" UseLayoutRounding="True" SnapsToDevicePixels="True" TextOptions.TextFormattingMode="Ideal" TextOptions.TextRenderingMode="ClearType" RenderOptions.ClearTypeHint="Enabled" WindowStyle="None" AllowsTransparency="False" ResizeMode="CanResize">

    <Window.Resources>
        <DataTemplate DataType="{x:Type vm:DashboardViewModel}">
            <views:DashboardView />
        </DataTemplate>
        <DataTemplate DataType="{x:Type vm:AnalysisWorkspaceViewModel}">
            <views:AnalysisWorkspaceView />
        </DataTemplate>
        <DataTemplate DataType="{x:Type vm:FileComparisonViewModel}">
            <views:FileComparisonView />
        </DataTemplate>
        <DataTemplate DataType="{x:Type vm:FileManagementViewModel}">
            <views:FileManagementView />
        </DataTemplate>
        <DataTemplate DataType="{x:Type vm:AnomalyDetailsViewModel}">
            <views:AnomalyDetailsView />
        </DataTemplate>

        <Style x:Key="SidebarButtonStyle" TargetType="Button">
            <Setter Property="Background" Value="Transparent"/>
            <Setter Property="Foreground" Value="{StaticResource Brush.Text.Muted}"/>
            <Setter Property="HorizontalContentAlignment" Value="Left"/>
            <Setter Property="Padding" Value="15,12"/>
            <Setter Property="Margin" Value="0,4"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="FontSize" Value="13"/>
            <Setter Property="FontWeight" Value="Medium"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border x:Name="BorderElement" Background="{TemplateBinding Background}" Padding="{TemplateBinding Padding}" CornerRadius="0" BorderBrush="Transparent" BorderThickness="0,0,0,0">
                            <ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="BorderElement" Property="Background">
                                    <Setter.Value>
                                        <SolidColorBrush Color="{StaticResource Color.Brand.Primary}" Opacity="0.1"/>
                                    </Setter.Value>
                                </Setter>
                                <Setter TargetName="BorderElement" Property="BorderBrush" Value="{StaticResource Brush.Action.Primary}"/>
                                <Setter TargetName="BorderElement" Property="BorderThickness" Value="0,0,3,0"/>
                                <Setter Property="Foreground" Value="{StaticResource Brush.Text.Primary}"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <Style x:Key="SidebarSectionHeaderStyle" TargetType="TextBlock">
            <Setter Property="Foreground" Value="{StaticResource Brush.Action.Primary}"/>
            <Setter Property="FontSize" Value="11"/>
            <Setter Property="FontWeight" Value="Bold"/>
            <Setter Property="Margin" Value="15,15,0,8"/>
            <Setter Property="Opacity" Value="0.8"/>
        </Style>
    </Window.Resources>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Custom Title Bar -->
        <Border Grid.Row="0" Background="{StaticResource Brush.App.Background}" BorderBrush="{StaticResource Brush.Action.Primary}" BorderThickness="0,0,0,2" Height="50" MouseLeftButtonDown="TitleBar_MouseLeftButtonDown">
            <Grid Margin="20,0">
                <StackPanel Orientation="Horizontal" VerticalAlignment="Center">
                    <Path Data="M12,2A9,9 0 0,0 3,11C3,14.03 4.53,16.82 7,18.47V22H9V19H11V22H13V19H15V22H17V18.46C19.47,16.81 21,14 21,11A9,9 0 0,0 12,2M8,11A2,2 0 0,1 10,13A2,2 0 0,1 8,15A2,2 0 0,1 6,13A2,2 0 0,1 8,11M16,11A2,2 0 0,1 18,13A2,2 0 0,1 16,15A2,2 0 0,1 14,13A2,2 0 0,1 16,11M12,14H14V17H10V14H12Z" Fill="{StaticResource Brush.Action.Primary}" Width="20" Height="20" Stretch="Uniform" Margin="0,0,12,0"/>
                    <TextBlock Text="DATASPECTER" Foreground="{StaticResource Brush.Text.Primary}" FontWeight="Bold" FontSize="16" VerticalAlignment="Center"/>
                    <TextBlock Text=" | Data Forensic Analysis" Foreground="{StaticResource Brush.Text.Muted}" FontSize="14" VerticalAlignment="Center" Margin="8,0,0,0"/>
                </StackPanel>
                <StackPanel Orientation="Horizontal" HorizontalAlignment="Right">
                    <Button Content="—" Width="45" Height="30" Background="Transparent" Foreground="{StaticResource Brush.Text.Muted}" BorderThickness="0" FontSize="16" Click="MinimizeButton_Click" Cursor="Hand">
                        <Button.Style>
                            <Style TargetType="Button">
                                <Setter Property="Template">
                                    <Setter.Value>
                                        <ControlTemplate TargetType="Button">
                                            <Border Background="{TemplateBinding Background}">
                                                <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                                            </Border>
                                        </ControlTemplate>
                                    </Setter.Value>
                                </Setter>
                                <Style.Triggers>
                                    <Trigger Property="IsMouseOver" Value="True">
                                        <Setter Property="Background" Value="#20FFFFFF"/>
                                    </Trigger>
                                </Style.Triggers>
                            </Style>
                        </Button.Style>
                    </Button>
                    <Button Content="☐" Width="45" Height="30" Background="Transparent" Foreground="{StaticResource Brush.Text.Muted}" BorderThickness="0" FontSize="16" Click="MaximizeButton_Click" Cursor="Hand">
                        <Button.Style>
                            <Style TargetType="Button">
                                <Setter Property="Template">
                                    <Setter.Value>
                                        <ControlTemplate TargetType="Button">
                                            <Border Background="{TemplateBinding Background}">
                                                <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                                            </Border>
                                        </ControlTemplate>
                                    </Setter.Value>
                                </Setter>
                                <Style.Triggers>
                                    <Trigger Property="IsMouseOver" Value="True">
                                        <Setter Property="Background" Value="#20FFFFFF"/>
                                    </Trigger>
                                </Style.Triggers>
                            </Style>
                        </Button.Style>
                    </Button>
                    <Button Content="✕" Width="45" Height="30" Background="Transparent" Foreground="{StaticResource Brush.Text.Muted}" BorderThickness="0" FontSize="16" Click="CloseButton_Click" Cursor="Hand">
                        <Button.Style>
                            <Style TargetType="Button">
                                <Setter Property="Template">
                                    <Setter.Value>
                                        <ControlTemplate TargetType="Button">
                                            <Border Background="{TemplateBinding Background}">
                                                <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                                            </Border>
                                        </ControlTemplate>
                                    </Setter.Value>
                                </Setter>
                                <Style.Triggers>
                                    <Trigger Property="IsMouseOver" Value="True">
                                        <Setter Property="Background" Value="{StaticResource Brush.Action.Destructive}"/>
                                        <Setter Property="Foreground" Value="White"/>
                                    </Trigger>
                                </Style.Triggers>
                            </Style>
                        </Button.Style>
                    </Button>
                </StackPanel>
            </Grid>
        </Border>

        <Grid Grid.Row="1">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="260"/>
                <ColumnDefinition Width="*"/>
            </Grid.ColumnDefinitions>

            <!-- Sidebar -->
            <Border Grid.Column="0" Background="{StaticResource Brush.Panel.Background}" BorderBrush="{StaticResource Brush.Action.Primary}" BorderThickness="0,0,2,0">
                <Border.Effect>
                    <DropShadowEffect Color="{StaticResource Color.Brand.Primary}" BlurRadius="20" ShadowDepth="0" Opacity="0.3" Direction="0"/>
                </Border.Effect>
                <ScrollViewer VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Disabled">
                    <StackPanel Margin="12">

                        <TextBlock Text="FORENSICS" Style="{StaticResource SidebarSectionHeaderStyle}"/>

                        <StackPanel>
                            <Button Command="{Binding NavigateToDashboardCommand}" Content="📊  Dashboard" Style="{StaticResource SidebarButtonStyle}" />
                            <Button Command="{Binding NavigateToAnalysisCommand}" Content="🔍  Analysis Workspace" Style="{StaticResource SidebarButtonStyle}" />
                            <Button Command="{Binding NavigateToComparisonCommand}" Content="⚖️  File Comparison" Style="{StaticResource SidebarButtonStyle}" />
                            <Button Command="{Binding NavigateToFilesCommand}" Content="📁  File Management" Style="{StaticResource SidebarButtonStyle}" />
                        </StackPanel>

                        <Rectangle Height="1" Fill="{StaticResource Brush.Action.Primary}" Opacity="0.2" Margin="15,20"/>

                        <TextBlock Text="TOOLS" Style="{StaticResource SidebarSectionHeaderStyle}"/>

                        <Button Command="{Binding OpenFileCommand}" Content="📂  Load External" Style="{StaticResource SidebarButtonStyle}"/>

                        <Rectangle Height="1" Fill="{StaticResource Brush.Action.Primary}" Opacity="0.2" Margin="15,20"/>

                        <Button Command="{Binding ExitCommand}" Content="🚪  Exit Application" Style="{StaticResource SidebarButtonStyle}"/>

                    </StackPanel>
                </ScrollViewer>
            </Border>

            <!-- Content Area -->
            <Grid Grid.Column="1">
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                </Grid.RowDefinitions>

                <!-- Status Bar -->
                <Border Grid.Row="0" Background="{StaticResource Brush.Panel.Background}" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="0,0,0,1" Padding="25,12">
                    <Grid>
                        <StackPanel Orientation="Horizontal">
                            <Rectangle Width="3" Height="18" Fill="{StaticResource Brush.Action.Primary}" Margin="0,0,10,0"/>
                            <TextBlock Text="{Binding StatusMessage}" Foreground="{StaticResource Brush.Text.Muted}" FontSize="12" VerticalAlignment="Center"/>
                        </StackPanel>
                    </Grid>
                </Border>

                <!-- Main Content -->
                <ContentControl Grid.Row="1" Content="{Binding CurrentViewModel}"/>
            </Grid>
        </Grid>
    </Grid>
</Window>

C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\MAINWINDOW.XAML.CS CODE IS BELOW
﻿using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using DataSpecter.UI.ViewModels;

namespace DataSpecter.UI
{
    public partial class MainWindow : Window
    {
        // The ViewModel is injected here automatically by App.xaml.cs
        public MainWindow(MainViewModel viewModel)
        {
            InitializeComponent();

            // This links the XAML to the C# Code
            DataContext = viewModel;
            
            // Start maximized
            WindowState = WindowState.Maximized;
        }

        private void GlassPanel_MouseMove(object sender, MouseEventArgs e)
        {
            if (sender is ContentControl panel)
            {
                if (panel.Template.FindName("PointerHighlightBrush", panel) is RadialGradientBrush brush)
                {
                    Point p = e.GetPosition(panel);

                    if (panel.ActualWidth > 0 && panel.ActualHeight > 0)
                    {
                        double x = p.X / panel.ActualWidth;
                        double y = p.Y / panel.ActualHeight;

                        brush.Center = new Point(x, y);
                        brush.GradientOrigin = new Point(x, y);
                    }
                }
            }
        }

        private void TitleBar_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (e.ClickCount == 2)
            {
                WindowState = WindowState == WindowState.Maximized ? WindowState.Normal : WindowState.Maximized;
            }
            else
            {
                DragMove();
            }
        }

        private void MinimizeButton_Click(object sender, RoutedEventArgs e)
        {
            WindowState = WindowState.Minimized;
        }

        private void MaximizeButton_Click(object sender, RoutedEventArgs e)
        {
            WindowState = WindowState == WindowState.Maximized ? WindowState.Normal : WindowState.Maximized;
        }

        private void CloseButton_Click(object sender, RoutedEventArgs e)
        {
            Close();
        }
    }
}

C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\MODELS\BYTEITEM.CS CODE IS BELOW
namespace DataSpecter.UI.Models
{
    public class ByteItem
    {
        public byte Value { get; set; }
        public long Offset { get; set; }
        public bool IsHighlighted { get; set; }

        public ByteItem(byte value, long offset, bool isHighlighted = false)
        {
            Value = value;
            Offset = offset;
            IsHighlighted = isHighlighted;
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\MODELS\FILEMODEL.CS CODE IS BELOW
using CommunityToolkit.Mvvm.ComponentModel;
using DataSpecter.Core.Models;
using System;

namespace DataSpecter.UI.Models
{
    public partial class FileModel : ObservableObject
    {
        [ObservableProperty]
        private int _id;

        [ObservableProperty]
        private string _name = string.Empty;

        [ObservableProperty]
        private string _path = string.Empty;

        [ObservableProperty]
        private long _size;

        [ObservableProperty]
        private string _status = "Pending";
        
        [ObservableProperty]
        private long _suffixArrayCount;

        [ObservableProperty]
        private TimeSpan _suffixArrayTime;
        
        [ObservableProperty]
        private long _lcpArrayCount;

        [ObservableProperty]
        private TimeSpan _lcpArrayTime;

        [ObservableProperty]
        private string _indexingStage = string.Empty;

        [ObservableProperty]
        private int _indexingProgress;

        [ObservableProperty]
        private string _indexingDetails = string.Empty;

        public int[]? SuffixArray { get; set; }
        public int[]? LcpArray { get; set; }

        public BinaryDataSource? DataSource { get; set; }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\MODELS\HEXROW.CS CODE IS BELOW
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DataSpecter.UI.Models
{
    public class HexRow
    {
        public long Offset { get; set; }
        public List<ByteItem> Items { get; set; } = new List<ByteItem>();
        
        public string AsciiText
        {
            get
            {
                var sb = new StringBuilder();
                foreach (var item in Items)
                {
                    // Convert byte to ASCII, show '.' for non-printable characters
                    char c = (item.Value >= 32 && item.Value <= 126) ? (char)item.Value : '.';
                    sb.Append(c);
                }
                return sb.ToString();
            }
        }

        public HexRow(long offset, IEnumerable<ByteItem> items)
        {
            Offset = offset;
            Items.AddRange(items);
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\THEMES\BRUSHES.XAML CODE IS BELOW
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">

    <SolidColorBrush x:Key="Brush.App.Background" Color="{StaticResource Color.Base.900}"/>
    <SolidColorBrush x:Key="Brush.Panel.Background" Color="{StaticResource Color.Base.800}"/>
    <SolidColorBrush x:Key="Brush.Panel.Border" Color="{StaticResource Color.Base.700}"/>

    <SolidColorBrush x:Key="Brush.Text.Primary" Color="{StaticResource Color.Text.Primary}"/>
    <SolidColorBrush x:Key="Brush.Text.Muted" Color="{StaticResource Color.Text.Muted}"/>
    <SolidColorBrush x:Key="Brush.Text.Inverted" Color="{StaticResource Color.Text.Inverted}"/>

    <SolidColorBrush x:Key="Brush.Action.Primary" Color="{StaticResource Color.Brand.Primary}"/>
    <SolidColorBrush x:Key="Brush.Action.Destructive" Color="{StaticResource Color.Status.Error}"/>

    <SolidColorBrush x:Key="Brush.Input.Background" Color="{StaticResource Color.Base.900}"/>
    <SolidColorBrush x:Key="Brush.Input.Border" Color="{StaticResource Color.Base.700}"/>

    <SolidColorBrush x:Key="Brush.Hex.Offset" Color="{StaticResource Color.Brand.Primary}" Opacity="0.8"/>

    <SolidColorBrush x:Key="Brush.Hex.Byte" Color="{StaticResource Color.Text.Primary}"/>

    <SolidColorBrush x:Key="Brush.Hex.Highlight" Color="{StaticResource Color.Brand.Primary}" Opacity="0.25"/>
    <SolidColorBrush x:Key="Brush.Hex.Selection" Color="{StaticResource Color.Brand.Primary}" Opacity="0.4"/>

    <SolidColorBrush x:Key="Brush.Scroll.Thumb" Color="{StaticResource Color.Base.600}"/>

    <SolidColorBrush x:Key="Brush.Status.Success" Color="{StaticResource Color.Status.Success}"/>

</ResourceDictionary>

C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\THEMES\COLORS.XAML CODE IS BELOW
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Color x:Key="Color.Base.900">#000000</Color>
    <Color x:Key="Color.Base.800">#0d0d0d</Color>
    <Color x:Key="Color.Base.700">#2B2B2B</Color>
    <Color x:Key="Color.Base.600">#454545</Color>
    <Color x:Key="Color.Brand.Primary">#FB2C36</Color>
    <Color x:Key="Color.Status.Error">#EF4444</Color>
    <Color x:Key="Color.Brand.Secondary">#FF9640</Color>

    <Color x:Key="Color.Text.Primary">#FAFAFA</Color>
    <Color x:Key="Color.Text.Muted">#A3A3A3</Color>
    <Color x:Key="Color.Text.Inverted">#000000</Color>
    <Color x:Key="Color.Chart.1">#E76E50</Color>
    <Color x:Key="Color.Chart.2">#2A9D90</Color>
    <Color x:Key="Color.Chart.3">#E9C46A</Color>
    <Color x:Key="Color.Status.Success">#10B981</Color>
</ResourceDictionary>

C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWMODELS\ANALYSISWORKSPACEVIEWMODEL.CS CODE IS BELOW
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using DataSpecter.UI.Models;
using DataSpecter.Core.Interfaces;
using System.Collections.ObjectModel;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace DataSpecter.UI.ViewModels
{
    public partial class AnalysisWorkspaceViewModel : ObservableObject
    {
        [ObservableProperty]
        private ObservableCollection<FileModel> _files;

        [ObservableProperty]
        private FileModel? _selectedFile;

        [ObservableProperty]
        private string _searchQuery = string.Empty;

        [ObservableProperty]
        private bool _isHex = false;

        [ObservableProperty]
        private ObservableCollection<HexRow>? _hexData;

        [ObservableProperty]
        private string _textData = string.Empty;

        [ObservableProperty]
        private System.Windows.Documents.FlowDocument? _textDocument;

        [ObservableProperty]
        private long _viewOffset = 0;

        [ObservableProperty]
        private long _pageSize = 16384; // 16KB default page size for smooth rendering

        [ObservableProperty]
        private long _totalSize = 0;

        [ObservableProperty]
        private string _filePositionInfo = string.Empty;

        [ObservableProperty]
        private bool _canNavigateNext = false;

        [ObservableProperty]
        private bool _canNavigatePrevious = false;

        [ObservableProperty]
        private ObservableCollection<long> _searchResults = new();

        [ObservableProperty]
        private int _searchCount;

        [ObservableProperty]
        private bool _isSearching = false;

        [ObservableProperty]
        private string _searchStatus = string.Empty;

        [ObservableProperty]
        private System.Collections.Generic.List<DataSpecter.Core.Models.StructureItem>? _structureRoot;

        [ObservableProperty]
        private bool _hasStructure;

        [ObservableProperty]
        private long _highlightOffset = -1;

        [ObservableProperty]
        private int _highlightLength = 0;

        private readonly Action<FileModel, long, long>? _navigateToAnomalyAction;
        private readonly IEntropyService? _entropyService;
        private readonly ISuffixArrayService? _suffixArrayService;
        private readonly System.Collections.Generic.List<DataSpecter.Core.Interfaces.IStructureParser> _parsers;

        public AnalysisWorkspaceViewModel(ObservableCollection<FileModel> files, IEntropyService entropyService, ISuffixArrayService? suffixArrayService = null, Action<FileModel, long, long>? navigateToAnomalyAction = null)
        {
            _files = files;
            _entropyService = entropyService;
            _suffixArrayService = suffixArrayService;
            _navigateToAnomalyAction = navigateToAnomalyAction;
            
            _parsers = new System.Collections.Generic.List<DataSpecter.Core.Interfaces.IStructureParser>
            {
                new DataSpecter.Infrastructure.Parsers.PeParser(),
                new DataSpecter.Infrastructure.Parsers.PdfParser()
            };
        }

        [RelayCommand]
        private void CalculateEntropy()
        {
            if (SelectedFile?.DataSource == null || _entropyService == null) return;

            // Create and show the entropy analysis window
            var viewModel = new EntropyAnalysisViewModel(
                SelectedFile.DataSource, 
                _entropyService, 
                SelectedFile.Name);

            var window = new DataSpecter.UI.Views.EntropyAnalysisWindow
            {
                DataContext = viewModel,
                Owner = System.Windows.Application.Current.MainWindow
            };

            // Start analysis asynchronously after window is shown
            window.Loaded += async (s, e) =>
            {
                await viewModel.StartAnalysisAsync();
            };

            window.ShowDialog();
        }

        [RelayCommand]
        private void IsolateAnomaly()
        {
            if (SelectedFile == null || SelectedFile.LcpArray == null || SelectedFile.SuffixArray == null || SelectedFile.DataSource == null)
            {
                // Can't analyze if not indexed
                return;
            }

            // Find Longest Repeated Substring (LRS)
            // LRS is the max value in the LCP array
            // The position in LCP array (say 'i') corresponds to SuffixArray[i] and SuffixArray[i-1] sharing that prefix.
            
            int maxLcp = 0;
            int maxIndex = 0;

            // Naive scan (fast enough for 100MB arrays usually)
            var lcp = SelectedFile.LcpArray;
            for (int i = 1; i < lcp.Length; i++)
            {
                if (lcp[i] > maxLcp)
                {
                    maxLcp = lcp[i];
                    maxIndex = i;
                }
            }

            if (maxLcp > 0)
            {
                // The substring starts at SuffixArray[maxIndex] with length maxLcp
                long offset = SelectedFile.SuffixArray[maxIndex];
                long length = maxLcp;

                _navigateToAnomalyAction?.Invoke(SelectedFile, offset, length);
            }
        }

        [RelayCommand]
        private async Task Search()
        {
            SearchResults.Clear();
            SearchCount = 0;
            SearchStatus = string.Empty;
            if (string.IsNullOrEmpty(SearchQuery) || SelectedFile?.DataSource == null) 
            {
                SearchStatus = "Enter a search query";
                return;
            }

            IsSearching = true;
            try
            {
                byte[] pattern;
                try 
                {
                    if (IsHex)
                    {
                        // Convert Hex String "0A 1B FF" -> byte[]
                         string cleanHex = SearchQuery.Replace(" ", "").Replace("0x", "");
                         if (cleanHex.Length % 2 != 0) 
                         {
                             SearchStatus = "Invalid hex string (must have even number of characters)";
                             return;
                         }
                         pattern = Convert.FromHexString(cleanHex);
                    }
                    else
                    {
                        pattern = System.Text.Encoding.UTF8.GetBytes(SearchQuery);
                    }
                }
                catch (Exception ex)
                {
                    SearchStatus = $"Error parsing search query: {ex.Message}";
                    return;
                }

                if (pattern.Length == 0) 
                {
                    SearchStatus = "Pattern is empty";
                    return;
                }

                SearchStatus = "Searching...";

                System.Diagnostics.Debug.WriteLine($"[Search] Query: '{SearchQuery}', IsHex: {IsHex}");
                System.Diagnostics.Debug.WriteLine($"[Search] Pattern length: {pattern.Length}, bytes: {string.Join(" ", pattern.Select(b => b.ToString("X2")))}");
                System.Diagnostics.Debug.WriteLine($"[Search] File indexed: {SelectedFile.SuffixArray != null}, SA length: {SelectedFile.SuffixArray?.Length ?? 0}");
                System.Diagnostics.Debug.WriteLine($"[Search] File size: {SelectedFile.DataSource.Length}");

                // Use Suffix Array if available for O(M log N) speed
                if (SelectedFile.SuffixArray != null && _suffixArrayService != null)
                {
                    var offsets = await _suffixArrayService.SearchAsync(SelectedFile.DataSource, SelectedFile.SuffixArray, pattern).ConfigureAwait(false);
                    
                    await System.Windows.Application.Current.Dispatcher.InvokeAsync(() =>
                    {
                        SearchCount = offsets.Length;
                        
                        // If too many results, limit display to prevent UI freeze, but keep count accurate
                        if (offsets.Length > 10000)
                        {
                            var limited = new long[10000];
                            Array.Copy(offsets, limited, 10000);
                            SearchResults = new ObservableCollection<long>(limited);
                            SearchStatus = $"Found {offsets.Length:N0} matches (showing first 10,000)";
                        }
                        else
                        {
                            SearchResults = new ObservableCollection<long>(offsets);
                            SearchStatus = offsets.Length == 0 ? "No matches found" : $"Found {offsets.Length:N0} matches";
                        }
                    });
                }
                else
                {
                     // Fallback to naive search
                     SearchStatus = "Searching (file not indexed - searching first 10MB)...";
                     
                     var results = await Task.Run(() =>
                     {
                         long fileLength = SelectedFile.DataSource.Length;
                         byte[] buffer = new byte[8192];
                         long limit = Math.Min(fileLength, 10 * 1024 * 1024);
                         var foundResults = new System.Collections.Generic.List<long>();

                         for (long i = 0; i < limit; i += (buffer.Length - pattern.Length + 1))
                         {
                             int read = SelectedFile.DataSource.ReadRange(i, buffer, 0, (int)Math.Min(buffer.Length, limit - i));
                             if (read < pattern.Length) break;

                             for (int j = 0; j <= read - pattern.Length; j++)
                             {
                                 bool match = true;
                                 for (int k = 0; k < pattern.Length; k++)
                                 {
                                     if (buffer[j + k] != pattern[k])
                                     {
                                         match = false;
                                         break;
                                     }
                                 }
                                 if (match)
                                 {
                                     foundResults.Add(i + j);
                                     if (foundResults.Count >= 10000) break;
                                 }
                             }
                             if (foundResults.Count >= 10000) break;
                         }
                         return foundResults;
                     }).ConfigureAwait(false);
                     
                     await System.Windows.Application.Current.Dispatcher.InvokeAsync(() =>
                     {
                         SearchCount = results.Count;
                         SearchResults = new ObservableCollection<long>(results);
                         SearchStatus = results.Count == 0 ? "No matches found" : $"Found {results.Count:N0} matches";
                     });
                }
            }
            finally
            {
                IsSearching = false;
            }
        }
        
        [RelayCommand]
        private void NavigateNext()
        {
            if (CanNavigateNext)
            {
                ViewOffset += PageSize;
                LoadViewData();
            }
        }

        [RelayCommand]
        private void NavigatePrevious()
        {
            if (CanNavigatePrevious)
            {
                ViewOffset = Math.Max(0, ViewOffset - PageSize);
                LoadViewData();
            }
        }

        [RelayCommand]
        private void NavigateToStart()
        {
            ViewOffset = 0;
            LoadViewData();
        }

        [RelayCommand]
        private void NavigateToEnd()
        {
            if (SelectedFile?.DataSource != null)
            {
                ViewOffset = Math.Max(0, SelectedFile.DataSource.Length - PageSize);
                LoadViewData();
            }
        }

        [RelayCommand]
        private void NavigateToOffset(long offset)
        {
            if (SelectedFile?.DataSource == null) return;

            // Store the pattern length from the last search
            byte[] pattern;
            try
            {
                if (IsHex)
                {
                    string cleanHex = SearchQuery.Replace(" ", "").Replace("0x", "");
                    if (cleanHex.Length % 2 != 0) return;
                    pattern = Convert.FromHexString(cleanHex);
                }
                else
                {
                    pattern = System.Text.Encoding.UTF8.GetBytes(SearchQuery);
                }
            }
            catch
            {
                pattern = Array.Empty<byte>();
            }

            // Set highlight range
            HighlightOffset = offset;
            HighlightLength = pattern.Length;

            // Calculate which page contains this offset (center it if possible)
            long halfPage = PageSize / 2;
            ViewOffset = Math.Max(0, offset - halfPage);
            
            // Make sure we don't go past the end
            if (ViewOffset + PageSize > SelectedFile.DataSource.Length)
            {
                ViewOffset = Math.Max(0, SelectedFile.DataSource.Length - PageSize);
            }

            LoadViewData();
        }

        [RelayCommand]
        private void ExportResults()
        {
            if (SearchResults.Count == 0 || SelectedFile?.DataSource == null) return;
            
            // Get the search pattern for context extraction
            byte[] pattern;
            try
            {
                if (IsHex)
                {
                    string cleanHex = SearchQuery.Replace(" ", "").Replace("0x", "");
                    if (cleanHex.Length % 2 != 0) return;
                    pattern = Convert.FromHexString(cleanHex);
                }
                else
                {
                    pattern = System.Text.Encoding.UTF8.GetBytes(SearchQuery);
                }
            }
            catch
            {
                pattern = Array.Empty<byte>();
            }

            // Build CSV with context
            var csv = "Offset (Decimal),Offset (Hex),Match Text,Context (350 chars max)\n";
            
            foreach(var offset in SearchResults)
            {
                string matchText = "";
                string context = "";
                
                try
                {
                    // Read the matched pattern
                    byte[] matchBuffer = new byte[pattern.Length];
                    SelectedFile.DataSource.ReadRange(offset, matchBuffer, 0, pattern.Length);
                    matchText = System.Text.Encoding.UTF8.GetString(matchBuffer).Replace("\"", "\"\"").Replace("\n", "\\n").Replace("\r", "\\r").Replace("\t", "\\t");
                    
                    // Extract context (350 chars centered around the match)
                    int contextLength = 350;
                    int halfContext = contextLength / 2;
                    
                    // Calculate start position (try to center the match)
                    long contextStart = Math.Max(0, offset - halfContext);
                    
                    // Read buffer for context
                    int bufferSize = Math.Min(contextLength * 2, (int)(SelectedFile.DataSource.Length - contextStart));
                    byte[] contextBuffer = new byte[bufferSize];
                    int bytesRead = SelectedFile.DataSource.ReadRange(contextStart, contextBuffer, 0, bufferSize);
                    
                    // Convert to text
                    string fullContext = System.Text.Encoding.UTF8.GetString(contextBuffer, 0, bytesRead);
                    
                    // Find line boundaries around the match position
                    int relativeMatchPos = (int)(offset - contextStart);
                    
                    // Find start of line (search backwards for newline)
                    int lineStart = relativeMatchPos;
                    while (lineStart > 0 && fullContext[lineStart - 1] != '\n' && fullContext[lineStart - 1] != '\r')
                    {
                        lineStart--;
                    }
                    
                    // Find end of line (search forwards for newline)
                    int lineEnd = relativeMatchPos + pattern.Length;
                    while (lineEnd < fullContext.Length && fullContext[lineEnd] != '\n' && fullContext[lineEnd] != '\r')
                    {
                        lineEnd++;
                    }
                    
                    // Extract the line
                    string line = fullContext.Substring(lineStart, lineEnd - lineStart);
                    
                    // If line is too long, truncate to 350 chars centered around match
                    if (line.Length > contextLength)
                    {
                        int matchPosInLine = relativeMatchPos - lineStart;
                        int extractStart = Math.Max(0, matchPosInLine - halfContext);
                        int extractLength = Math.Min(contextLength, line.Length - extractStart);
                        
                        line = line.Substring(extractStart, extractLength);
                        
                        // Add ellipsis if truncated
                        if (extractStart > 0) line = "..." + line;
                        if (extractStart + extractLength < fullContext.Substring(lineStart, lineEnd - lineStart).Length) line = line + "...";
                    }
                    
                    // Clean up for CSV
                    context = line.Replace("\"", "\"\"").Replace("\t", "\\t");
                }
                catch
                {
                    matchText = "[Error reading]";
                    context = "[Error extracting context]";
                }
                
                csv += $"{offset},0x{offset:X},\"{matchText}\",\"{context}\"\n";
            }
            
            string path = System.IO.Path.Combine(System.IO.Path.GetTempPath(), $"DataSpecter_Export_{DateTime.Now.Ticks}.csv");
            System.IO.File.WriteAllText(path, csv);
            
            // Open the CSV file
            System.Diagnostics.Process.Start(new System.Diagnostics.ProcessStartInfo(path) { UseShellExecute = true });
        }
        
        partial void OnSelectedFileChanged(FileModel? value)
        {
            LoadViewData();
        }

        partial void OnViewOffsetChanged(long value)
        {
            LoadViewData();
        }

        partial void OnPageSizeChanged(long value)
        {
            LoadViewData();
        }

        private async void LoadViewData()
        {
            if (SelectedFile?.DataSource != null)
            {
                TotalSize = SelectedFile.DataSource.Length;
                
                // Clamp page size to reasonable bounds
                int actualPageSize = (int)Math.Min(PageSize, TotalSize - ViewOffset);
                if (actualPageSize <= 0) actualPageSize = 1024;
                
                byte[] buffer = new byte[actualPageSize];
                int read = SelectedFile.DataSource.ReadRange(ViewOffset, buffer, 0, actualPageSize);
                
                // If read < actualPageSize, resize buffer for display purposes
                if (read < actualPageSize)
                {
                    Array.Resize(ref buffer, read);
                }
                
                // Create virtualized HexRow collection (16 bytes per row)
                var hexRows = new ObservableCollection<HexRow>();
                int bytesPerRow = 16;
                for (int i = 0; i < read; i += bytesPerRow)
                {
                    var rowItems = new System.Collections.Generic.List<ByteItem>();
                    int rowLength = Math.Min(bytesPerRow, read - i);
                    
                    for (int j = 0; j < rowLength; j++)
                    {
                        long currentOffset = ViewOffset + i + j;
                        bool isHighlighted = HighlightOffset >= 0 && 
                                            currentOffset >= HighlightOffset && 
                                            currentOffset < HighlightOffset + HighlightLength;
                        rowItems.Add(new ByteItem(buffer[i + j], currentOffset, isHighlighted));
                    }
                    
                    hexRows.Add(new HexRow(ViewOffset + i, rowItems));
                }
                HexData = hexRows;
                
                // Create text document with highlighting support
                TextData = System.Text.Encoding.UTF8.GetString(buffer);
                
                // Create FlowDocument for highlighted text view
                var flowDoc = new System.Windows.Documents.FlowDocument();
                var paragraph = new System.Windows.Documents.Paragraph();
                
                if (HighlightOffset >= 0 && HighlightLength > 0)
                {
                    // Calculate relative positions within the current view
                    long relativeHighlightStart = HighlightOffset - ViewOffset;
                    
                    if (relativeHighlightStart >= 0 && relativeHighlightStart < read)
                    {
                        // Add text before highlight
                        if (relativeHighlightStart > 0)
                        {
                            string beforeText = System.Text.Encoding.UTF8.GetString(buffer, 0, (int)relativeHighlightStart);
                            paragraph.Inlines.Add(new System.Windows.Documents.Run(beforeText));
                        }
                        
                        // Add highlighted text
                        int highlightStartInBuffer = (int)relativeHighlightStart;
                        int highlightEndInBuffer = Math.Min((int)(relativeHighlightStart + HighlightLength), read);
                        int highlightLengthInBuffer = highlightEndInBuffer - highlightStartInBuffer;
                        
                        if (highlightLengthInBuffer > 0)
                        {
                            string highlightedText = System.Text.Encoding.UTF8.GetString(buffer, highlightStartInBuffer, highlightLengthInBuffer);
                            var highlightRun = new System.Windows.Documents.Run(highlightedText)
                            {
                                Background = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(255, 255, 0)), // Yellow
                                Foreground = System.Windows.Media.Brushes.Black,
                                FontWeight = System.Windows.FontWeights.Bold
                            };
                            paragraph.Inlines.Add(highlightRun);
                        }
                        
                        // Add text after highlight
                        if (highlightEndInBuffer < read)
                        {
                            string afterText = System.Text.Encoding.UTF8.GetString(buffer, highlightEndInBuffer, read - highlightEndInBuffer);
                            paragraph.Inlines.Add(new System.Windows.Documents.Run(afterText));
                        }
                    }
                    else
                    {
                        // Highlight not in current view, just add all text
                        paragraph.Inlines.Add(new System.Windows.Documents.Run(TextData));
                    }
                }
                else
                {
                    // No highlight, add all text
                    paragraph.Inlines.Add(new System.Windows.Documents.Run(TextData));
                }
                
                flowDoc.Blocks.Add(paragraph);
                TextDocument = flowDoc;
                
                // Update position info
                long endOffset = Math.Min(ViewOffset + read, TotalSize);
                FilePositionInfo = $"Showing bytes {ViewOffset:N0} - {endOffset:N0} of {TotalSize:N0} ({(endOffset * 100.0 / TotalSize):F1}%)";
                
                // Update navigation state
                CanNavigatePrevious = ViewOffset > 0;
                CanNavigateNext = ViewOffset + read < TotalSize;

                // Structure Parsing
                StructureRoot = null;
                HasStructure = false;
                
                // Read header for detection (10 bytes)
                byte[] header = new byte[10];
                SelectedFile.DataSource.ReadRange(0, header, 0, 10);
                
                foreach(var parser in _parsers)
                {
                    if (parser.CanParse(SelectedFile.Name, header))
                    {
                        StructureRoot = await parser.ParseAsync(SelectedFile.DataSource);
                        HasStructure = true;
                        break;
                    }
                }
            }
            else
            {
                HexData = null;
                TextData = string.Empty;
                StructureRoot = null;
                HasStructure = false;
            }
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWMODELS\ANOMALYDETAILSVIEWMODEL.CS CODE IS BELOW
using CommunityToolkit.Mvvm.ComponentModel;
using DataSpecter.UI.Models;
using System;

namespace DataSpecter.UI.ViewModels
{
    public partial class AnomalyDetailsViewModel : ObservableObject
    {
        [ObservableProperty]
        private FileModel? _file;
        
        [ObservableProperty]
        private long _offset;
        
        [ObservableProperty]
        private long _length;
        
        [ObservableProperty]
        private byte[]? _data;
        
        [ObservableProperty]
        private byte[]? _hexData; // Using byte[] for ItemsControl binding in UI

        [ObservableProperty]
        private string _textData = string.Empty;

        public void Initialize(FileModel file, long offset, long length)
        {
            File = file;
            Offset = offset;
            Length = length;

            if (File?.DataSource != null)
            {
                // Cap length for display safety (e.g. 1MB max for detail view)
                int safeLength = (int)Math.Min(length, 1024 * 1024);
                byte[] buffer = new byte[safeLength];
                
                int read = File.DataSource.ReadRange(offset, buffer, 0, safeLength);
                
                if (read < safeLength)
                {
                    Array.Resize(ref buffer, read);
                }

                Data = buffer;
                HexData = buffer;
                TextData = System.Text.Encoding.UTF8.GetString(buffer);
            }
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWMODELS\DASHBOARDVIEWMODEL.CS CODE IS BELOW
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using DataSpecter.UI.Models;
using DataSpecter.Core.Interfaces;
using System.Collections.ObjectModel;
using System.Linq;
using System;
using System.Threading.Tasks;

namespace DataSpecter.UI.ViewModels
{
    public partial class DashboardViewModel : ObservableObject
    {
        [ObservableProperty]
        private ObservableCollection<FileModel> _files;

        [ObservableProperty]
        private int _totalEvidence;

        [ObservableProperty]
        private int _fullyIndexed;
        
        [ObservableProperty]
        private string _indexingStrategy = "Optimized";

                private readonly Action _browseFilesAction;
                private readonly Action<string[]> _filesDroppedAction;
                private readonly ISuffixArrayService _suffixArrayService;
                private readonly IFileService _fileService;
        
                public DashboardViewModel(ObservableCollection<FileModel> files, ISuffixArrayService suffixArrayService, IFileService fileService, Action browseFilesAction, Action<string[]> filesDroppedAction)
                {
                    _files = files;
                    _suffixArrayService = suffixArrayService;
                    _fileService = fileService;
                    _browseFilesAction = browseFilesAction;
                    _filesDroppedAction = filesDroppedAction;
                    _files.CollectionChanged += (s, e) => UpdateStats();
                    UpdateStats();
                }
        
                private void UpdateStats()
                {
                    TotalEvidence = Files.Count;
                    FullyIndexed = Files.Count(f => f.Status == "indexed");
                }
        
                [RelayCommand]
                private void UploadFiles() 
                {
                     _browseFilesAction?.Invoke();
                }
        
                [RelayCommand]
                private void DropFiles(string[]? files)
                {
                    if (files != null && files.Length > 0)
                    {
                        _filesDroppedAction?.Invoke(files);
                    }
                }
                
                [RelayCommand]
                private async Task IndexFile(FileModel? file)
                {
                    if(file == null || file.Status == "indexed" || file.DataSource == null) return;
                    
                    try
                    {
                        file.Status = "indexing";
                        file.IndexingProgress = 0;
                        file.IndexingStage = "Initializing";
                        file.IndexingDetails = "";
                        
                        // 1. Try Load Persistence
                        var existing = await _fileService.LoadIndexAsync(file.Path);
                        
                        if (existing != null)
                        {
                             file.SuffixArray = existing.Value.sa;
                             file.LcpArray = existing.Value.lcp;
                             file.SuffixArrayCount = existing.Value.sa.Length;
                             file.LcpArrayCount = existing.Value.lcp.Length;
                             // Times are unknown if loaded, set to zero or small val
                             file.SuffixArrayTime = TimeSpan.Zero;
                             file.LcpArrayTime = TimeSpan.Zero;
                        }
                        else
                        {
                            // 2. Generate with progress reporting
                            var progress = new Progress<(string stage, int current, int total, double percentage)>(report =>
                            {
                                file.IndexingStage = report.stage;
                                file.IndexingProgress = (int)report.percentage;
                                file.IndexingDetails = $"{report.current:N0} / {report.total:N0} ({report.percentage:F1}%)";
                            });

                            var result = await _suffixArrayService.GenerateAsync(file.DataSource, progress);
                            
                            file.SuffixArrayCount = result.saCount;
                            file.SuffixArrayTime = result.saTime;
                            file.SuffixArray = result.suffixArray;
                            
                            file.LcpArrayCount = result.lcpCount;
                            file.LcpArrayTime = result.lcpTime;
                            file.LcpArray = result.lcpArray;
                            
                            // 3. Save Persistence
                            await _fileService.SaveIndexAsync(file.Path, file.SuffixArray, file.LcpArray);
                        }
        
                        file.Status = "indexed";
                        file.IndexingProgress = 100;
                        file.IndexingStage = "Complete";
                        UpdateStats();
                    }
                    catch (Exception ex)
                    {
                        file.Status = "error";
                        file.IndexingStage = "Error";
                        file.IndexingDetails = ex.Message;
                        // In a real app we'd log this or show a message
                        System.Diagnostics.Debug.WriteLine($"Indexing failed: {ex.Message}");
                    }
                }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWMODELS\ENTROPYANALYSISVIEWMODEL.CS CODE IS BELOW
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using DataSpecter.Core.Interfaces;
using DataSpecter.Core.Models;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;

namespace DataSpecter.UI.ViewModels
{
    public partial class EntropyAnalysisViewModel : ObservableObject
    {
        private readonly BinaryDataSource _dataSource;
        private readonly IEntropyService _entropyService;

        [ObservableProperty]
        private bool _isCalculating = true;

        [ObservableProperty]
        private int _calculationProgress = 0;

        [ObservableProperty]
        private string _calculationStatus = "Initializing...";

        [ObservableProperty]
        private bool _hasResults = false;

        [ObservableProperty]
        private double[]? _entropyData;

        [ObservableProperty]
        private double[]? _rawEntropyData; // Keep raw data for export

        [ObservableProperty]
        private double[]? _byteFrequencies;

        [ObservableProperty]
        private double _averageEntropy;

        [ObservableProperty]
        private double _minEntropy;

        [ObservableProperty]
        private double _maxEntropy;

        [ObservableProperty]
        private double _stdDevEntropy;

        [ObservableProperty]
        private int _chunkCount;

        [ObservableProperty]
        private string _chunkSize = string.Empty;

        [ObservableProperty]
        private string _fileName;

        [ObservableProperty]
        private string _fileSize = string.Empty;

        [ObservableProperty]
        private string _compressionHint = string.Empty;

        [ObservableProperty]
        private string _encryptionHint = string.Empty;

        [ObservableProperty]
        private string _dataTypeHint = string.Empty;

        public EntropyAnalysisViewModel(BinaryDataSource dataSource, IEntropyService entropyService, string fileName)
        {
            _dataSource = dataSource;
            _entropyService = entropyService;
            FileName = fileName;
            FileSize = FormatFileSize(dataSource.Length);
        }

        public async Task StartAnalysisAsync()
        {
            try
            {
                IsCalculating = true;
                HasResults = false;
                CalculationProgress = 0;
                CalculationStatus = "Calculating entropy...";

                // Create progress reporter
                var progress = new Progress<(int current, int total)>(report =>
                {
                    CalculationProgress = (int)((report.current * 50.0) / report.total); // First 50%
                    CalculationStatus = $"Analyzing entropy: {report.current:N0} / {report.total:N0} chunks";
                });

                // Calculate entropy with dynamic chunk sizing
                var entropyResult = await CalculateEntropyWithProgressAsync(progress);
                RawEntropyData = entropyResult.data;
                ChunkSize = FormatFileSize(entropyResult.chunkSize);
                ChunkCount = entropyResult.data.Length;

                CalculationProgress = 50;
                CalculationStatus = "Calculating byte frequencies...";

                // Calculate byte frequency distribution
                var frequencies = await CalculateByteFrequenciesAsync();
                
                CalculationProgress = 75;
                CalculationStatus = "Analyzing data patterns...";

                // Calculate statistics
                CalculateStatistics(RawEntropyData);

                // Downsample for display (limit to 500 bars)
                EntropyData = DownsampleData(RawEntropyData, 500);

                // Normalize byte frequencies for display (0-8 scale like entropy)
                ByteFrequencies = NormalizeFrequencies(frequencies);

                CalculationProgress = 90;
                CalculationStatus = "Generating insights...";

                // Generate file insights
                GenerateInsights();

                CalculationProgress = 100;
                CalculationStatus = "Analysis complete!";
                HasResults = true;

                await Task.Delay(500);
                IsCalculating = false;
            }
            catch (Exception ex)
            {
                CalculationStatus = $"Error: {ex.Message}";
                MessageBox.Show($"Failed to analyze file: {ex.Message}", "Analysis Error", MessageBoxButton.OK, MessageBoxImage.Error);
                IsCalculating = false;
            }
        }

        private async Task<(double[] data, int chunkSize)> CalculateEntropyWithProgressAsync(IProgress<(int current, int total)> progress)
        {
            return await Task.Run(() =>
            {
                long length = _dataSource.Length;

                // Calculate appropriate chunk size to limit memory usage
                const int maxInitialChunks = 10000;
                const int minChunkSize = 1024;
                const int maxChunkSize = 1024 * 1024;

                int chunkSize = (int)Math.Min(maxChunkSize, Math.Max(minChunkSize, length / maxInitialChunks));
                int numChunks = (int)((length + chunkSize - 1) / chunkSize);

                double[] entropyValues = new double[numChunks];
                byte[] buffer = new byte[chunkSize];

                int reportInterval = Math.Max(1, numChunks / 100);

                for (int i = 0; i < numChunks; i++)
                {
                    long offset = (long)i * chunkSize;
                    int read = _dataSource.ReadRange(offset, buffer, 0, chunkSize);

                    if (read > 0)
                    {
                        entropyValues[i] = CalculateShannonEntropy(buffer, read);
                    }

                    if (i % reportInterval == 0 || i == numChunks - 1)
                    {
                        progress?.Report((i + 1, numChunks));
                    }
                }

                return (entropyValues, chunkSize);
            });
        }

        private async Task<long[]> CalculateByteFrequenciesAsync()
        {
            return await Task.Run(() =>
            {
                long[] frequencies = new long[256];
                byte[] buffer = new byte[65536]; // 64KB buffer for fast reading
                long offset = 0;
                long length = _dataSource.Length;

                // Sample up to 10MB for byte frequency (faster for large files)
                long maxBytesToSample = Math.Min(length, 10 * 1024 * 1024);

                while (offset < maxBytesToSample)
                {
                    int toRead = (int)Math.Min(buffer.Length, maxBytesToSample - offset);
                    int read = _dataSource.ReadRange(offset, buffer, 0, toRead);
                    
                    if (read == 0) break;

                    for (int i = 0; i < read; i++)
                    {
                        frequencies[buffer[i]]++;
                    }

                    offset += read;
                }

                return frequencies;
            });
        }

        private double CalculateShannonEntropy(byte[] buffer, int count)
        {
            if (count == 0) return 0.0;

            int[] frequencies = new int[256];
            for (int i = 0; i < count; i++)
            {
                frequencies[buffer[i]]++;
            }

            double entropy = 0.0;
            double log2 = Math.Log(2);

            for (int i = 0; i < 256; i++)
            {
                if (frequencies[i] > 0)
                {
                    double p = (double)frequencies[i] / count;
                    entropy -= p * (Math.Log(p) / log2);
                }
            }

            return entropy;
        }

        private void CalculateStatistics(double[] data)
        {
            if (data == null || data.Length == 0)
            {
                AverageEntropy = MinEntropy = MaxEntropy = StdDevEntropy = 0;
                return;
            }

            AverageEntropy = data.Average();
            MinEntropy = data.Min();
            MaxEntropy = data.Max();

            // Calculate standard deviation
            double sumOfSquares = data.Sum(val => Math.Pow(val - AverageEntropy, 2));
            StdDevEntropy = Math.Sqrt(sumOfSquares / data.Length);
        }

        private double[] DownsampleData(double[] data, int maxBars)
        {
            if (data.Length <= maxBars) return data;

            double ratio = (double)data.Length / maxBars;
            double[] result = new double[maxBars];

            for (int i = 0; i < maxBars; i++)
            {
                int startIdx = (int)(i * ratio);
                int endIdx = (int)((i + 1) * ratio);
                
                double sum = 0;
                int count = 0;
                for (int j = startIdx; j < endIdx && j < data.Length; j++)
                {
                    sum += data[j];
                    count++;
                }
                
                result[i] = count > 0 ? sum / count : 0;
            }

            return result;
        }

        private double[] NormalizeFrequencies(long[] frequencies)
        {
            if (frequencies.Length == 0) return Array.Empty<double>();

            long max = frequencies.Max();
            if (max == 0) return frequencies.Select(_ => 0.0).ToArray();

            // Normalize to 0-8 scale (matching entropy scale)
            return frequencies.Select(f => (f / (double)max) * 8.0).ToArray();
        }

        private void GenerateInsights()
        {
            // Analyze compression potential
            if (AverageEntropy < 3.0)
            {
                CompressionHint = "🔹 Low entropy detected. File contains repetitive patterns and could compress significantly.";
            }
            else if (AverageEntropy < 6.0)
            {
                CompressionHint = "🔹 Moderate entropy. File may benefit from compression.";
            }
            else
            {
                CompressionHint = "🔹 High entropy. File is likely already compressed or encrypted, or contains random data.";
            }

            // Analyze encryption/randomness
            if (AverageEntropy > 7.5 && StdDevEntropy < 0.3)
            {
                EncryptionHint = "🔐 Very high uniform entropy suggests encrypted or highly compressed data.";
            }
            else if (AverageEntropy > 7.0)
            {
                EncryptionHint = "🔐 High entropy with variation suggests mixed content or partial encryption.";
            }
            else
            {
                EncryptionHint = "🔓 Entropy patterns suggest unencrypted data.";
            }

            // Analyze data type
            if (ByteFrequencies != null)
            {
                double nullByteFreq = ByteFrequencies[0];
                double printableFreq = 0;
                
                // Sum frequencies of printable ASCII range (0x20-0x7E)
                for (int i = 0x20; i <= 0x7E; i++)
                {
                    printableFreq += ByteFrequencies[i];
                }

                if (printableFreq > 5.0) // Significant printable characters
                {
                    DataTypeHint = "📝 High concentration of printable characters suggests text-based content.";
                }
                else if (nullByteFreq > 6.0) // Many null bytes
                {
                    DataTypeHint = "💾 High null byte frequency suggests binary data with padding or sparse structures.";
                }
                else
                {
                    DataTypeHint = "📦 Byte distribution suggests binary or mixed content.";
                }
            }
        }

        [RelayCommand]
        private async Task ExportCsv()
        {
            try
            {
                var dialog = new Microsoft.Win32.SaveFileDialog
                {
                    FileName = $"{Path.GetFileNameWithoutExtension(FileName)}_entropy",
                    DefaultExt = ".csv",
                    Filter = "CSV files (*.csv)|*.csv|All files (*.*)|*.*"
                };

                if (dialog.ShowDialog() == true)
                {
                    var sb = new StringBuilder();
                    sb.AppendLine("Chunk Index,Offset,Entropy");

                    if (RawEntropyData != null)
                    {
                        int chunkSizeBytes = int.Parse(ChunkSize.Split(' ')[0]);
                        for (int i = 0; i < RawEntropyData.Length; i++)
                        {
                            long offset = (long)i * chunkSizeBytes;
                            sb.AppendLine($"{i},0x{offset:X8},{RawEntropyData[i]:F6}");
                        }
                    }

                    await File.WriteAllTextAsync(dialog.FileName, sb.ToString());
                    MessageBox.Show($"Entropy data exported to:\n{dialog.FileName}", "Export Successful", 
                        MessageBoxButton.OK, MessageBoxImage.Information);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to export CSV: {ex.Message}", "Export Error", 
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        [RelayCommand]
        private async Task ExportReport()
        {
            try
            {
                var dialog = new Microsoft.Win32.SaveFileDialog
                {
                    FileName = $"{Path.GetFileNameWithoutExtension(FileName)}_analysis_report",
                    DefaultExt = ".txt",
                    Filter = "Text files (*.txt)|*.txt|All files (*.*)|*.*"
                };

                if (dialog.ShowDialog() == true)
                {
                    var sb = new StringBuilder();
                    sb.AppendLine("═══════════════════════════════════════════════════════");
                    sb.AppendLine("           ENTROPY ANALYSIS REPORT");
                    sb.AppendLine("═══════════════════════════════════════════════════════");
                    sb.AppendLine();
                    sb.AppendLine($"File: {FileName}");
                    sb.AppendLine($"Size: {FileSize}");
                    sb.AppendLine($"Analysis Date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
                    sb.AppendLine();
                    sb.AppendLine("───────────────────────────────────────────────────────");
                    sb.AppendLine("ENTROPY STATISTICS");
                    sb.AppendLine("───────────────────────────────────────────────────────");
                    sb.AppendLine($"Average Entropy:      {AverageEntropy:F4}");
                    sb.AppendLine($"Minimum Entropy:      {MinEntropy:F4}");
                    sb.AppendLine($"Maximum Entropy:      {MaxEntropy:F4}");
                    sb.AppendLine($"Standard Deviation:   {StdDevEntropy:F4}");
                    sb.AppendLine($"Total Chunks:         {ChunkCount:N0}");
                    sb.AppendLine($"Chunk Size:           {ChunkSize}");
                    sb.AppendLine();
                    sb.AppendLine("───────────────────────────────────────────────────────");
                    sb.AppendLine("FILE INSIGHTS");
                    sb.AppendLine("───────────────────────────────────────────────────────");
                    sb.AppendLine(CompressionHint);
                    sb.AppendLine(EncryptionHint);
                    sb.AppendLine(DataTypeHint);
                    sb.AppendLine();
                    
                    if (ByteFrequencies != null)
                    {
                        sb.AppendLine("───────────────────────────────────────────────────────");
                        sb.AppendLine("TOP 10 MOST FREQUENT BYTES");
                        sb.AppendLine("───────────────────────────────────────────────────────");
                        
                        var topBytes = ByteFrequencies
                            .Select((freq, idx) => new { Byte = idx, Frequency = freq })
                            .OrderByDescending(x => x.Frequency)
                            .Take(10);

                        foreach (var item in topBytes)
                        {
                            string byteChar = item.Byte >= 0x20 && item.Byte <= 0x7E 
                                ? $"'{(char)item.Byte}'" 
                                : "   ";
                            sb.AppendLine($"  0x{item.Byte:X2} {byteChar}  -  {item.Frequency:F2} (relative frequency)");
                        }
                    }

                    await File.WriteAllTextAsync(dialog.FileName, sb.ToString());
                    MessageBox.Show($"Analysis report exported to:\n{dialog.FileName}", "Export Successful", 
                        MessageBoxButton.OK, MessageBoxImage.Information);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to export report: {ex.Message}", "Export Error", 
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        [RelayCommand]
        private async Task Recalculate()
        {
            await StartAnalysisAsync();
        }

        private string FormatFileSize(long bytes)
        {
            string[] sizes = { "B", "KB", "MB", "GB", "TB" };
            double size = bytes;
            int order = 0;
            
            while (size >= 1024 && order < sizes.Length - 1)
            {
                order++;
                size /= 1024;
            }

            return $"{size:F2} {sizes[order]}";
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWMODELS\FILECOMPARISONVIEWMODEL.CS CODE IS BELOW
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using DataSpecter.UI.Models;
using DataSpecter.Core.Interfaces;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System;

namespace DataSpecter.UI.ViewModels
{
    public partial class FileComparisonViewModel : ObservableObject
    {
        private readonly ILcsService? _lcsService;
        private readonly IFuzzyHashService? _fuzzyHashService;

        [ObservableProperty]
        private ObservableCollection<FileModel> _files;
        
        [ObservableProperty]
        private FileModel? _selectedFile1;
        
        [ObservableProperty]
        private FileModel? _selectedFile2;

        [ObservableProperty]
        private ObservableCollection<HexRow>? _hexData1;
        
        [ObservableProperty]
        private ObservableCollection<HexRow>? _hexData2;

        [ObservableProperty]
        private bool _isCalculating;
        
        [ObservableProperty]
        private bool _isResultReady;

        [ObservableProperty]
        private long _lcsLength;
        
        [ObservableProperty]
        private long _lcsOffset1;
        
        [ObservableProperty]
        private long _lcsOffset2;
        
        [ObservableProperty]
        private string _lcsText = string.Empty;

        [ObservableProperty]
        private TimeSpan _comparisonDuration;
        
        [ObservableProperty]
        private long _file1Length;
        
        [ObservableProperty]
        private long _file2Length;

        // Fuzzy Hash Properties
        [ObservableProperty]
        private bool _isFuzzyHashCalculated;

        [ObservableProperty]
        private string _fuzzyHash1 = string.Empty;

        [ObservableProperty]
        private string _fuzzyHash2 = string.Empty;

        [ObservableProperty]
        private int _ssdeepScore = 0;

        [ObservableProperty]
        private double _byteLevelScore = 0.0;

        [ObservableProperty]
        private string _ssdeepScoreDescription = string.Empty;

        [ObservableProperty]
        private string _byteLevelScoreDescription = string.Empty;

        [ObservableProperty]
        private int _commonChunksCount = 0;

        [ObservableProperty]
        private string _similarityInsight = string.Empty;

        // Scroll properties for HexViewers
        [ObservableProperty]
        private long _scrollOffset1;

        [ObservableProperty]
        private long _scrollOffset2;

        public FileComparisonViewModel(ObservableCollection<FileModel> files, ILcsService? lcsService = null, IFuzzyHashService? fuzzyHashService = null)
        {
             _files = files;
             _lcsService = lcsService;
             _fuzzyHashService = fuzzyHashService;
        }

        [RelayCommand]
        private async Task Compare()
        {
            if (SelectedFile1?.DataSource == null || SelectedFile2?.DataSource == null || _lcsService == null) return;
            
            IsCalculating = true;
            IsResultReady = false;
            
            // Store file lengths for visualization
            File1Length = SelectedFile1.DataSource.Length;
            File2Length = SelectedFile2.DataSource.Length;
            
            // Allow UI to update and show spinner
            await Task.Delay(50);
            
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            var result = await _lcsService.FindLcsAsync(SelectedFile1.DataSource, SelectedFile2.DataSource);
            stopwatch.Stop();
            
            ComparisonDuration = stopwatch.Elapsed;
            LcsLength = result.length;
            LcsOffset1 = result.offset1;
            LcsOffset2 = result.offset2;

            // Load highlighted previews
            // Offload to background thread to prevent UI freeze during collection population
            var list1 = await Task.Run(() => LoadPreviewRows(SelectedFile1.DataSource, result.offset1, result.length));
            var list2 = await Task.Run(() => LoadPreviewRows(SelectedFile2.DataSource, result.offset2, result.length));

            HexData1 = new ObservableCollection<HexRow>(list1);
            HexData2 = new ObservableCollection<HexRow>(list2);
            
            // Extract text
            if (result.length > 0)
            {
                byte[] textBuf = new byte[Math.Min(result.length, 100)]; // Limit text preview
                SelectedFile1.DataSource.ReadRange(result.offset1, textBuf, 0, textBuf.Length);
                
                // Simple ASCII filtering
                char[] chars = new char[textBuf.Length];
                for(int i=0; i<textBuf.Length; i++)
                {
                    byte b = textBuf[i];
                    chars[i] = (b >= 32 && b <= 126) ? (char)b : '.';
                }
                LcsText = new string(chars);
                if (result.length > 100) LcsText += "...";
            }
            else
            {
                LcsText = "(No Match)";
            }
            
            IsCalculating = false;
            IsResultReady = true;

            // Calculate fuzzy hashes if service is available
            if (_fuzzyHashService != null)
            {
                await CalculateFuzzyHashesAsync();
            }
        }

        private async Task CalculateFuzzyHashesAsync()
        {
            if (SelectedFile1?.DataSource == null || SelectedFile2?.DataSource == null || _fuzzyHashService == null)
                return;

            try
            {
                // Compute fuzzy hashes
                FuzzyHash1 = await _fuzzyHashService.ComputeFuzzyHashAsync(SelectedFile1.DataSource);
                FuzzyHash2 = await _fuzzyHashService.ComputeFuzzyHashAsync(SelectedFile2.DataSource);

                // Compare fuzzy hashes
                SsdeepScore = _fuzzyHashService.CompareFuzzyHashes(FuzzyHash1, FuzzyHash2);

                // Byte-level similarity
                var similarity = await _fuzzyHashService.ComputeByteLevelSimilarityAsync(
                    SelectedFile1.DataSource,
                    SelectedFile2.DataSource,
                    SelectedFile1.SuffixArray,
                    SelectedFile1.LcpArray);

                ByteLevelScore = similarity.SimilarityPercentage;
                CommonChunksCount = similarity.CommonChunksCount;

                // Generate descriptions
                GenerateFuzzyHashDescriptions();
                GenerateSimilarityInsight();

                IsFuzzyHashCalculated = true;
            }
            catch (Exception)
            {
                // Silently fail fuzzy hash calculation - LCS still works
                IsFuzzyHashCalculated = false;
            }
        }

        private void GenerateFuzzyHashDescriptions()
        {
            // SSDEEP score description
            if (SsdeepScore >= 90)
                SsdeepScoreDescription = "Nearly Identical";
            else if (SsdeepScore >= 70)
                SsdeepScoreDescription = "Highly Similar";
            else if (SsdeepScore >= 50)
                SsdeepScoreDescription = "Moderately Similar";
            else if (SsdeepScore >= 30)
                SsdeepScoreDescription = "Somewhat Similar";
            else if (SsdeepScore >= 10)
                SsdeepScoreDescription = "Slightly Similar";
            else
                SsdeepScoreDescription = "Very Different";

            // Byte-level score description
            if (ByteLevelScore >= 90)
                ByteLevelScoreDescription = "Near-Perfect Match";
            else if (ByteLevelScore >= 70)
                ByteLevelScoreDescription = "Strong Correlation";
            else if (ByteLevelScore >= 50)
                ByteLevelScoreDescription = "Moderate Correlation";
            else if (ByteLevelScore >= 30)
                ByteLevelScoreDescription = "Some Correlation";
            else if (ByteLevelScore >= 10)
                ByteLevelScoreDescription = "Weak Correlation";
            else
                ByteLevelScoreDescription = "Minimal Correlation";
        }

        private void GenerateSimilarityInsight()
        {
            double avgScore = (SsdeepScore + ByteLevelScore) / 2.0;

            if (avgScore >= 80)
            {
                SimilarityInsight = "⚠️ HIGH SIMILARITY: Files are substantially similar. If comparing against known threats, this could indicate a variant or modified version.";
            }
            else if (avgScore >= 50)
            {
                SimilarityInsight = "🔍 MODERATE SIMILARITY: Files share significant common elements. May be related versions or contain common libraries.";
            }
            else if (avgScore >= 20)
            {
                SimilarityInsight = "📊 LOW SIMILARITY: Some common patterns detected but files are largely different.";
            }
            else
            {
                SimilarityInsight = "✓ MINIMAL SIMILARITY: Files appear unrelated with no significant matching patterns.";
            }
        }

        private System.Collections.Generic.List<HexRow> LoadPreviewRows(DataSpecter.Core.Models.BinaryDataSource source, long matchOffset, long matchLength)
        {
            var rows = new System.Collections.Generic.List<HexRow>();
            int previewSize = 4096;
            byte[] buf = new byte[previewSize];
            int read = source.ReadRange(0, buf, 0, previewSize);
            
            int bytesPerRow = 16;
            for (int i = 0; i < read; i += bytesPerRow)
            {
                var rowItems = new System.Collections.Generic.List<ByteItem>();
                for (int j = 0; j < bytesPerRow && (i + j) < read; j++)
                {
                    int index = i + j;
                    bool isHigh = (index >= matchOffset && index < matchOffset + matchLength);
                    rowItems.Add(new ByteItem(buf[index], index, isHigh));
                }
                rows.Add(new HexRow(i, rowItems));
            }
            return rows;
        }

        [RelayCommand]
        private void ScrollToMatch()
        {
            // Update scroll offsets to trigger scrolling in HexViewers
            ScrollOffset1 = LcsOffset1;
            ScrollOffset2 = LcsOffset2;
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWMODELS\FILEMANAGEMENTVIEWMODEL.CS CODE IS BELOW
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using DataSpecter.UI.Models;
using System.Collections.ObjectModel;
using System.Linq;

namespace DataSpecter.UI.ViewModels
{
    public partial class FileManagementViewModel : ObservableObject
    {
        [ObservableProperty]
        private ObservableCollection<FileModel> _files;

        public FileManagementViewModel(ObservableCollection<FileModel> files)
        {
             _files = files;
             _files.CollectionChanged += (s, e) => OnPropertyChanged(nameof(TotalSizeMB));
        }

        [RelayCommand]
        private void DeleteFile(FileModel? file)
        {
            if (file != null)
            {
                file.DataSource?.Dispose();
                Files.Remove(file);
            }
        }
        
        public double TotalSizeMB => Files.Sum(f => f.Size) / 1024.0 / 1024.0;
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWMODELS\FILESIMILARITYVIEWMODEL.CS CODE IS BELOW
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using DataSpecter.Core.Interfaces;
using DataSpecter.UI.Models;
using System;
using System.Collections.ObjectModel;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using System.Windows;

namespace DataSpecter.UI.ViewModels
{
    public partial class FileSimilarityViewModel : ObservableObject
    {
        private readonly IFuzzyHashService _fuzzyHashService;
        private readonly Action<FileModel, long, long>? _navigateToOffsetAction;

        [ObservableProperty]
        private ObservableCollection<FileModel> _availableFiles;

        [ObservableProperty]
        private FileModel? _file1;

        [ObservableProperty]
        private FileModel? _file2;

        [ObservableProperty]
        private string _file1Size = string.Empty;

        [ObservableProperty]
        private string _file2Size = string.Empty;

        [ObservableProperty]
        private bool _isComparing = false;

        [ObservableProperty]
        private int _comparisonProgress = 0;

        [ObservableProperty]
        private string _comparisonStatus = string.Empty;

        [ObservableProperty]
        private bool _hasResults = false;

        [ObservableProperty]
        private int _ssdeepScore = 0;

        [ObservableProperty]
        private double _byteLevelScore = 0.0;

        [ObservableProperty]
        private string _ssdeepScoreDescription = string.Empty;

        [ObservableProperty]
        private string _byteLevelScoreDescription = string.Empty;

        [ObservableProperty]
        private string _fuzzyHash1 = string.Empty;

        [ObservableProperty]
        private string _fuzzyHash2 = string.Empty;

        [ObservableProperty]
        private int _commonChunksCount = 0;

        [ObservableProperty]
        private string _bytesAnalyzed = string.Empty;

        [ObservableProperty]
        private string _longestMatchLength = string.Empty;

        [ObservableProperty]
        private string _matchOffset1 = string.Empty;

        [ObservableProperty]
        private string _matchOffset2 = string.Empty;

        [ObservableProperty]
        private string _analysisTime = string.Empty;

        [ObservableProperty]
        private string _similarityInsight = string.Empty;

        [ObservableProperty]
        private string _fuzzyHashInsight = string.Empty;

        [ObservableProperty]
        private string _byteLevelInsight = string.Empty;

        [ObservableProperty]
        private bool _hasLongestMatch = false;

        private long _longestMatchOffset1;
        private long _longestMatchOffset2;
        private int _longestMatchLen;

        public FileSimilarityViewModel(
            ObservableCollection<FileModel> files, 
            IFuzzyHashService fuzzyHashService,
            Action<FileModel, long, long>? navigateToOffsetAction = null)
        {
            _availableFiles = files;
            _fuzzyHashService = fuzzyHashService;
            _navigateToOffsetAction = navigateToOffsetAction;

            // Set default selections if we have files
            if (files.Count >= 2)
            {
                File1 = files[0];
                File2 = files[1];
            }
            else if (files.Count == 1)
            {
                File1 = files[0];
            }
        }

        partial void OnFile1Changed(FileModel? value)
        {
            File1Size = value?.DataSource != null ? FormatFileSize(value.DataSource.Length) : string.Empty;
        }

        partial void OnFile2Changed(FileModel? value)
        {
            File2Size = value?.DataSource != null ? FormatFileSize(value.DataSource.Length) : string.Empty;
        }

        [RelayCommand]
        private async Task Compare()
        {
            if (File1?.DataSource == null || File2?.DataSource == null)
            {
                MessageBox.Show("Please select two files to compare.", "Selection Required", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            if (File1 == File2)
            {
                MessageBox.Show("Please select two different files.", "Invalid Selection", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            try
            {
                IsComparing = true;
                HasResults = false;
                ComparisonProgress = 0;
                ComparisonStatus = "Initializing comparison...";

                // Step 1: Compute fuzzy hashes
                ComparisonStatus = "Computing fuzzy hash for File 1...";
                ComparisonProgress = 10;
                FuzzyHash1 = await _fuzzyHashService.ComputeFuzzyHashAsync(File1.DataSource);

                ComparisonStatus = "Computing fuzzy hash for File 2...";
                ComparisonProgress = 30;
                FuzzyHash2 = await _fuzzyHashService.ComputeFuzzyHashAsync(File2.DataSource);

                // Step 2: Compare fuzzy hashes
                ComparisonStatus = "Comparing fuzzy hashes...";
                ComparisonProgress = 50;
                SsdeepScore = _fuzzyHashService.CompareFuzzyHashes(FuzzyHash1, FuzzyHash2);

                // Step 3: Byte-level similarity
                ComparisonStatus = "Analyzing byte-level similarity...";
                ComparisonProgress = 60;
                var similarity = await _fuzzyHashService.ComputeByteLevelSimilarityAsync(
                    File1.DataSource, 
                    File2.DataSource,
                    File1.SuffixArray,
                    File1.LcpArray);

                ComparisonProgress = 90;
                ComparisonStatus = "Generating insights...";

                // Populate results
                ByteLevelScore = similarity.SimilarityPercentage;
                CommonChunksCount = similarity.CommonChunksCount;
                BytesAnalyzed = FormatFileSize(similarity.TotalBytesAnalyzed);
                
                _longestMatchLen = similarity.LongestCommonSubstringLength;
                _longestMatchOffset1 = similarity.LongestCommonSubstringOffset1;
                _longestMatchOffset2 = similarity.LongestCommonSubstringOffset2;
                
                LongestMatchLength = _longestMatchLen > 0 
                    ? $"{_longestMatchLen:N0} bytes" 
                    : "No significant matches";
                MatchOffset1 = _longestMatchLen > 0 
                    ? $"0x{_longestMatchOffset1:X8}" 
                    : "N/A";
                MatchOffset2 = _longestMatchLen > 0 
                    ? $"0x{_longestMatchOffset2:X8}" 
                    : "N/A";
                HasLongestMatch = _longestMatchLen > 0;
                
                AnalysisTime = $"{similarity.CalculationTimeMs:N0} ms";

                // Generate descriptions
                GenerateDescriptions();
                GenerateInsights();

                ComparisonProgress = 100;
                ComparisonStatus = "Analysis complete!";

                await Task.Delay(500);
                IsComparing = false;
                HasResults = true;
            }
            catch (Exception ex)
            {
                ComparisonStatus = $"Error: {ex.Message}";
                MessageBox.Show($"Failed to compare files: {ex.Message}", "Comparison Error", 
                    MessageBoxButton.OK, MessageBoxImage.Error);
                IsComparing = false;
            }
        }

        private void GenerateDescriptions()
        {
            // SSDEEP score description
            if (SsdeepScore >= 90)
                SsdeepScoreDescription = "Nearly Identical";
            else if (SsdeepScore >= 70)
                SsdeepScoreDescription = "Highly Similar";
            else if (SsdeepScore >= 50)
                SsdeepScoreDescription = "Moderately Similar";
            else if (SsdeepScore >= 30)
                SsdeepScoreDescription = "Somewhat Similar";
            else if (SsdeepScore >= 10)
                SsdeepScoreDescription = "Slightly Similar";
            else
                SsdeepScoreDescription = "Very Different";

            // Byte-level score description
            if (ByteLevelScore >= 90)
                ByteLevelScoreDescription = "Near-Perfect Match";
            else if (ByteLevelScore >= 70)
                ByteLevelScoreDescription = "Strong Correlation";
            else if (ByteLevelScore >= 50)
                ByteLevelScoreDescription = "Moderate Correlation";
            else if (ByteLevelScore >= 30)
                ByteLevelScoreDescription = "Some Correlation";
            else if (ByteLevelScore >= 10)
                ByteLevelScoreDescription = "Weak Correlation";
            else
                ByteLevelScoreDescription = "Minimal Correlation";
        }

        private void GenerateInsights()
        {
            // Overall similarity insight
            double avgScore = (SsdeepScore + ByteLevelScore) / 2.0;
            
            if (avgScore >= 80)
            {
                SimilarityInsight = "⚠️ HIGH SIMILARITY: These files are substantially similar. " +
                    "If comparing against a known threat, this could indicate a variant or modified version. " +
                    "Recommend thorough investigation of differences.";
            }
            else if (avgScore >= 50)
            {
                SimilarityInsight = "🔍 MODERATE SIMILARITY: Files share significant common elements. " +
                    "Could be related versions, similar file types, or contain common libraries/resources. " +
                    "Further analysis of unique sections recommended.";
            }
            else if (avgScore >= 20)
            {
                SimilarityInsight = "📊 LOW SIMILARITY: Some common patterns detected but files are largely different. " +
                    "May share common file format structures or small code sections.";
            }
            else
            {
                SimilarityInsight = "✓ MINIMAL SIMILARITY: Files appear to be unrelated. " +
                    "No significant matching patterns found beyond random chance.";
            }

            // Fuzzy hash insight
            if (SsdeepScore >= 70)
            {
                FuzzyHashInsight = $"🔐 SSDEEP Analysis: The fuzzy hash match of {SsdeepScore}% indicates files share similar " +
                    "structural patterns and chunk sequences. This is useful for detecting file modifications, " +
                    "where a small portion was changed but overall structure remains similar.";
            }
            else if (SsdeepScore >= 30)
            {
                FuzzyHashInsight = $"🔐 SSDEEP Analysis: Moderate fuzzy hash score ({SsdeepScore}%) suggests some structural " +
                    "similarities but significant differences exist. Files may be loosely related or share common components.";
            }
            else
            {
                FuzzyHashInsight = $"🔐 SSDEEP Analysis: Low fuzzy hash score ({SsdeepScore}%) indicates files have " +
                    "different structural patterns. They are likely unrelated or have been substantially modified.";
            }

            // Byte-level insight
            if (HasLongestMatch && _longestMatchLen >= 1024)
            {
                ByteLevelInsight = $"🎯 Byte-Level Analysis: Found significant matching sequence of {_longestMatchLen:N0} bytes. " +
                    "This could indicate copied code, embedded resources, or common libraries. " +
                    $"The match occurs at offset 0x{_longestMatchOffset1:X8} in File 1 and 0x{_longestMatchOffset2:X8} in File 2. " +
                    "Click 'VIEW LONGEST MATCH' to examine this section.";
            }
            else if (ByteLevelScore >= 50)
            {
                ByteLevelInsight = $"🎯 Byte-Level Analysis: {ByteLevelScore:F1}% chunk similarity detected across {CommonChunksCount:N0} matching chunks. " +
                    "Files share substantial binary content, suggesting they may be versions of the same file or contain significant common data.";
            }
            else if (ByteLevelScore >= 20)
            {
                ByteLevelInsight = $"🎯 Byte-Level Analysis: {ByteLevelScore:F1}% chunk similarity with {CommonChunksCount:N0} matching chunks. " +
                    "Some common binary patterns detected, but files have distinct content.";
            }
            else
            {
                ByteLevelInsight = $"🎯 Byte-Level Analysis: Minimal chunk overlap ({ByteLevelScore:F1}%). " +
                    "Files have very different binary content with no significant matching sequences.";
            }
        }

        [RelayCommand]
        private async Task ExportReport()
        {
            if (!HasResults) return;

            try
            {
                var dialog = new Microsoft.Win32.SaveFileDialog
                {
                    FileName = $"similarity_report_{DateTime.Now:yyyyMMdd_HHmmss}",
                    DefaultExt = ".txt",
                    Filter = "Text files (*.txt)|*.txt|All files (*.*)|*.*"
                };

                if (dialog.ShowDialog() == true)
                {
                    var sb = new StringBuilder();
                    sb.AppendLine("═══════════════════════════════════════════════════════════");
                    sb.AppendLine("          FILE SIMILARITY ANALYSIS REPORT");
                    sb.AppendLine("═══════════════════════════════════════════════════════════");
                    sb.AppendLine();
                    sb.AppendLine($"Report Date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
                    sb.AppendLine();
                    sb.AppendLine("───────────────────────────────────────────────────────────");
                    sb.AppendLine("FILES COMPARED");
                    sb.AppendLine("───────────────────────────────────────────────────────────");
                    sb.AppendLine($"File 1: {File1?.Name}");
                    sb.AppendLine($"  Size: {File1Size}");
                    sb.AppendLine();
                    sb.AppendLine($"File 2: {File2?.Name}");
                    sb.AppendLine($"  Size: {File2Size}");
                    sb.AppendLine();
                    sb.AppendLine("───────────────────────────────────────────────────────────");
                    sb.AppendLine("SIMILARITY SCORES");
                    sb.AppendLine("───────────────────────────────────────────────────────────");
                    sb.AppendLine($"Fuzzy Hash (SSDEEP):    {SsdeepScore}% ({SsdeepScoreDescription})");
                    sb.AppendLine($"Byte-Level Analysis:    {ByteLevelScore:F2}% ({ByteLevelScoreDescription})");
                    sb.AppendLine($"Overall Assessment:     {((SsdeepScore + ByteLevelScore) / 2):F2}%");
                    sb.AppendLine();
                    sb.AppendLine("───────────────────────────────────────────────────────────");
                    sb.AppendLine("FUZZY HASHES (SSDEEP)");
                    sb.AppendLine("───────────────────────────────────────────────────────────");
                    sb.AppendLine($"File 1: {FuzzyHash1}");
                    sb.AppendLine($"File 2: {FuzzyHash2}");
                    sb.AppendLine();
                    sb.AppendLine("───────────────────────────────────────────────────────────");
                    sb.AppendLine("BYTE-LEVEL STATISTICS");
                    sb.AppendLine("───────────────────────────────────────────────────────────");
                    sb.AppendLine($"Common Chunks:          {CommonChunksCount:N0}");
                    sb.AppendLine($"Bytes Analyzed:         {BytesAnalyzed}");
                    sb.AppendLine($"Longest Match:          {LongestMatchLength}");
                    sb.AppendLine($"Match Offset (File 1):  {MatchOffset1}");
                    sb.AppendLine($"Match Offset (File 2):  {MatchOffset2}");
                    sb.AppendLine($"Analysis Time:          {AnalysisTime}");
                    sb.AppendLine();
                    sb.AppendLine("───────────────────────────────────────────────────────────");
                    sb.AppendLine("ANALYSIS INSIGHTS");
                    sb.AppendLine("───────────────────────────────────────────────────────────");
                    sb.AppendLine();
                    sb.AppendLine(WrapText(SimilarityInsight, 60));
                    sb.AppendLine();
                    sb.AppendLine(WrapText(FuzzyHashInsight, 60));
                    sb.AppendLine();
                    sb.AppendLine(WrapText(ByteLevelInsight, 60));
                    sb.AppendLine();
                    sb.AppendLine("═══════════════════════════════════════════════════════════");
                    sb.AppendLine("        End of Report - DataSpecter Analysis Tool");
                    sb.AppendLine("═══════════════════════════════════════════════════════════");

                    await File.WriteAllTextAsync(dialog.FileName, sb.ToString());
                    MessageBox.Show($"Report exported to:\n{dialog.FileName}", "Export Successful", 
                        MessageBoxButton.OK, MessageBoxImage.Information);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to export report: {ex.Message}", "Export Error", 
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        [RelayCommand]
        private void NavigateToMatch()
        {
            if (!HasLongestMatch || File1 == null) return;

            _navigateToOffsetAction?.Invoke(File1, _longestMatchOffset1, _longestMatchLen);
        }

        private string FormatFileSize(long bytes)
        {
            string[] sizes = { "B", "KB", "MB", "GB", "TB" };
            double size = bytes;
            int order = 0;
            
            while (size >= 1024 && order < sizes.Length - 1)
            {
                order++;
                size /= 1024;
            }

            return $"{size:F2} {sizes[order]}";
        }

        private string WrapText(string text, int maxWidth)
        {
            if (string.IsNullOrEmpty(text) || text.Length <= maxWidth)
                return text;

            var sb = new StringBuilder();
            int currentPos = 0;

            while (currentPos < text.Length)
            {
                int remaining = text.Length - currentPos;
                int chunkSize = Math.Min(maxWidth, remaining);
                
                if (remaining > maxWidth)
                {
                    // Try to break at a space
                    int lastSpace = text.LastIndexOf(' ', currentPos + chunkSize, chunkSize);
                    if (lastSpace > currentPos)
                        chunkSize = lastSpace - currentPos;
                }

                sb.AppendLine(text.Substring(currentPos, chunkSize).Trim());
                currentPos += chunkSize;
            }

            return sb.ToString().TrimEnd();
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWMODELS\MAINVIEWMODEL.CS CODE IS BELOW
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Win32;
using System.Windows;
using DataSpecter.Core.Interfaces;
using DataSpecter.UI.Models;
using System.IO;
using System;
using System.Collections.ObjectModel;

namespace DataSpecter.UI.ViewModels
{
    public partial class MainViewModel : ObservableObject
    {
        private readonly IFileService _fileService;
        private readonly ISuffixArrayService _suffixArrayService;
        private readonly IEntropyService _entropyService;
        private readonly IFuzzyHashService _fuzzyHashService;
        private readonly ObservableCollection<FileModel> _files = new();

        [ObservableProperty]
        private string _windowTitle = "Data Specter";

        [ObservableProperty]
        private string _statusMessage = "Ready";
        
        // Navigation
        [ObservableProperty]
        private object _currentViewModel;

        public DashboardViewModel DashboardVM { get; }
        public AnalysisWorkspaceViewModel AnalysisVM { get; }
        public FileComparisonViewModel ComparisonVM { get; }
        public FileManagementViewModel ManagementVM { get; }
        public AnomalyDetailsViewModel AnomalyVM { get; } = new();

        public MainViewModel(
            IFileService fileService, 
            ISuffixArrayService suffixArrayService, 
            IEntropyService entropyService, 
            ILcsService lcsService, 
            IFuzzyHashService fuzzyHashService)
        {
            _fileService = fileService;
            _suffixArrayService = suffixArrayService;
            _entropyService = entropyService;
            _fuzzyHashService = fuzzyHashService;

            // Initialize child VMs with shared state and delegates
            DashboardVM = new DashboardViewModel(_files, _suffixArrayService, _fileService, OpenFile, LoadFiles);
            AnalysisVM = new AnalysisWorkspaceViewModel(_files, _entropyService, _suffixArrayService, NavigateToAnomaly);
            ComparisonVM = new FileComparisonViewModel(_files, lcsService, _fuzzyHashService);
            ManagementVM = new FileManagementViewModel(_files);

            CurrentViewModel = DashboardVM;
        }

        [RelayCommand]
        private void NavigateToDashboard() => CurrentViewModel = DashboardVM;

        [RelayCommand]
        private void NavigateToAnalysis() => CurrentViewModel = AnalysisVM;

        [RelayCommand]
        private void NavigateToComparison() => CurrentViewModel = ComparisonVM;
        
        [RelayCommand]
        private void NavigateToFiles() => CurrentViewModel = ManagementVM;

        public void NavigateToAnomaly(FileModel file, long offset, long length)
        {
            AnomalyVM.Initialize(file, offset, length);
            CurrentViewModel = AnomalyVM;
        }

        private void LoadFiles(string[] paths)
        {
             StatusMessage = "Loading files...";
             foreach (var path in paths)
             {
                try
                {
                    if (!File.Exists(path)) continue;

                    var dataSource = _fileService.OpenFile(path);
                    
                    var fileModel = new FileModel
                    {
                        Id = _files.Count + 1,
                        Name = Path.GetFileName(path),
                        Path = path,
                        Size = dataSource.Length,
                        Status = "Ready",
                        DataSource = dataSource
                    };

                    _files.Add(fileModel);
                    StatusMessage = $"Loaded: {fileModel.Name}";
                }
                catch (Exception ex)
                {
                    StatusMessage = $"Error loading {Path.GetFileName(path)}";
                    MessageBox.Show($"Failed to load file: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                }
             }
        }

        [RelayCommand]
        private void OpenFile()
        {
            var dialog = new OpenFileDialog
            {
                Title = "Select Forensic Target",
                Filter = "Forensic Targets (*.txt;*.log;*.dll;*.pdf;*.bin;*.exe)|*.txt;*.log;*.dll;*.pdf;*.bin;*.exe|All Files (*.*)|*.*",
                CheckFileExists = true,
                Multiselect = true 
            };

            if (dialog.ShowDialog() == true)
            {
                LoadFiles(dialog.FileNames);
            }
        }

        [RelayCommand]
        private void Exit()
        {
            // Cleanup
            foreach(var file in _files)
            {
                file.DataSource?.Dispose();
            }
            Application.Current.Shutdown();
        }
    }
}

C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWS\ANALYSISWORKSPACEVIEW.XAML CODE IS BELOW
<UserControl x:Class="DataSpecter.UI.Views.AnalysisWorkspaceView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:converters="clr-namespace:DataSpecter.UI.Converters" mc:Ignorable="d" d:DesignHeight="450" d:DesignWidth="800">
    <UserControl.Resources>
        <BooleanToVisibilityConverter x:Key="BooleanToVisibilityConverter"/>
    </UserControl.Resources>
    <Grid>
        <Grid.Background>
            <RadialGradientBrush GradientOrigin="0.5,0.5" Center="0.5,0.5" RadiusX="1.2" RadiusY="1.2">
                <GradientStop Color="#1a0505" Offset="0.0"/>
                <GradientStop Color="#000000" Offset="1.0"/>
            </RadialGradientBrush>
        </Grid.Background>

        <Path Data="M12,2A9,9 0 0,0 3,11C3,14.03 4.53,16.82 7,18.47V22H9V19H11V22H13V19H15V22H17V18.46C19.47,16.81 21,14 21,11A9,9 0 0,0 12,2M8,11A2,2 0 0,1 10,13A2,2 0 0,1 8,15A2,2 0 0,1 6,13A2,2 0 0,1 8,11M16,11A2,2 0 0,1 18,13A2,2 0 0,1 16,15A2,2 0 0,1 14,13A2,2 0 0,1 16,11M12,14H14V17H10V14H12Z" Fill="#33FF0000" Stretch="Uniform" Width="450" Height="450" HorizontalAlignment="Center" VerticalAlignment="Center" Opacity="0.08" IsHitTestVisible="False">
            <Path.Effect>
                <DropShadowEffect Color="#FF0000" BlurRadius="50" ShadowDepth="0" Opacity="0.5"/>
            </Path.Effect>
        </Path>

        <Canvas x:Name="ParticleCanvas" IsHitTestVisible="False" ClipToBounds="True"/>

        <Grid>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="250"/>
                <ColumnDefinition Width="*"/>
                <ColumnDefinition Width="250"/>
            </Grid.ColumnDefinitions>

            <!-- Left Panel -->
            <Border Grid.Column="0" BorderBrush="{StaticResource Brush.Action.Primary}" BorderThickness="0,0,1,0" Padding="10">
                <StackPanel>
                    <TextBlock Text="EVIDENCE SELECTION" FontSize="10" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,0,5"/>
                    <ComboBox ItemsSource="{Binding Files}" SelectedItem="{Binding SelectedFile}" DisplayMemberPath="Name" Margin="0,0,0,20"/>

                    <TextBlock Text="PATTERN DISCOVERY" FontSize="10" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,0,5"/>
                    <TextBox Text="{Binding SearchQuery, UpdateSourceTrigger=PropertyChanged}" Margin="0,0,0,5" Padding="5"/>

                    <CheckBox Content="Hex Search" IsChecked="{Binding IsHex}" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,0,5"/>

                    <!-- Search Status -->
                    <TextBlock Text="{Binding SearchStatus}" Foreground="{StaticResource Brush.Text.Primary}" FontSize="10" Margin="0,5,0,5" TextWrapping="Wrap">
                        <TextBlock.Style>
                            <Style TargetType="TextBlock">
                                <Setter Property="Visibility" Value="Visible"/>
                                <Style.Triggers>
                                    <DataTrigger Binding="{Binding SearchStatus}" Value="">
                                        <Setter Property="Visibility" Value="Collapsed"/>
                                    </DataTrigger>
                                    <DataTrigger Binding="{Binding SearchStatus}" Value="{x:Null}">
                                        <Setter Property="Visibility" Value="Collapsed"/>
                                    </DataTrigger>
                                </Style.Triggers>
                            </Style>
                        </TextBlock.Style>
                    </TextBlock>

                    <StackPanel Orientation="Horizontal" Grid.Row="2" Margin="0,5,0,0">
                        <Button Command="{Binding SearchCommand}" Content="🔍  SEARCH" Padding="15,8" FontWeight="Bold" FontSize="12">
                            <Button.Style>
                                <Style TargetType="Button" BasedOn="{StaticResource {x:Type Button}}">
                                    <Setter Property="IsEnabled" Value="True"/>
                                    <Style.Triggers>
                                        <DataTrigger Binding="{Binding IsSearching}" Value="True">
                                            <Setter Property="IsEnabled" Value="False"/>
                                            <Setter Property="Content" Value="🔍  SEARCHING..."/>
                                        </DataTrigger>
                                    </Style.Triggers>
                                </Style>
                            </Button.Style>
                        </Button>
                        <Button Command="{Binding ExportResultsCommand}" Content="📊  EXPORT CSV" Padding="15,8" Margin="10,0,0,0" FontWeight="Bold" FontSize="12">
                            <Button.Style>
                                <Style TargetType="Button" BasedOn="{StaticResource {x:Type Button}}">
                                    <Setter Property="Visibility" Value="Visible"/>
                                    <Style.Triggers>
                                        <DataTrigger Binding="{Binding SearchResults.Count}" Value="0">
                                            <Setter Property="Visibility" Value="Collapsed"/>
                                        </DataTrigger>
                                    </Style.Triggers>
                                </Style>
                            </Button.Style>
                        </Button>
                    </StackPanel>

                    <TextBlock Text="ADVANCED TOOLS" FontSize="10" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,15,0,5"/>
                    <Button Command="{Binding IsolateAnomalyCommand}" Content="🎯  ISOLATE ANOMALY" Margin="0,0,0,5" Padding="15,8" FontWeight="Bold" FontSize="12" ToolTip="Find Longest Repeated Substring automatically"/>
                    <Button Command="{Binding CalculateEntropyCommand}" Content="📈  ENTROPY ANALYSIS" Margin="0,0,0,5" Padding="15,8" FontWeight="Bold" FontSize="12" ToolTip="Open detailed entropy analysis window"/>
                </StackPanel>
            </Border>

            <!-- Center: Data Viewer -->
            <Border Grid.Column="1" Background="{StaticResource Brush.Panel.Background}" Padding="0">
                <Grid>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="*"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>

                    <!-- File Position Info -->
                    <Border Grid.Row="0" Background="#111" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="0,0,0,1" Padding="10,5">
                        <StackPanel>
                            <TextBlock Text="{Binding FilePositionInfo}" Foreground="{StaticResource Brush.Text.Primary}" FontFamily="Consolas" FontSize="11"/>
                            <StackPanel Orientation="Horizontal" Margin="0,5,0,0">
                                <TextBlock Text="Page Size: " Foreground="{StaticResource Brush.Text.Muted}" FontSize="10" VerticalAlignment="Center" Margin="0,0,5,0"/>
                                <ComboBox SelectedValue="{Binding PageSize}" SelectedValuePath="Tag" Width="100" FontSize="10">
                                    <ComboBoxItem Content="4 KB" Tag="4096"/>
                                    <ComboBoxItem Content="16 KB" Tag="16384" IsSelected="True"/>
                                    <ComboBoxItem Content="64 KB" Tag="65536"/>
                                    <ComboBoxItem Content="256 KB" Tag="262144"/>
                                    <ComboBoxItem Content="1 MB" Tag="1048576"/>
                                </ComboBox>
                            </StackPanel>
                        </StackPanel>
                    </Border>

                    <TabControl Grid.Row="1" Background="Transparent" BorderThickness="0">
                        <TabControl.Resources>
                            <Style TargetType="TabItem">
                                <Setter Property="Template">
                                    <Setter.Value>
                                        <ControlTemplate TargetType="TabItem">
                                            <Border Name="Border" Background="Transparent" Padding="15,10" BorderBrush="Transparent" BorderThickness="0,0,0,3" Margin="0,0,2,0" CornerRadius="0">
                                                <ContentPresenter x:Name="ContentSite" VerticalAlignment="Center" HorizontalAlignment="Center" ContentSource="Header" Margin="0"/>
                                            </Border>
                                            <ControlTemplate.Triggers>
                                                <Trigger Property="IsSelected" Value="True">
                                                    <Setter TargetName="Border" Property="BorderBrush" Value="{StaticResource Brush.Action.Primary}" />
                                                    <Setter TargetName="Border" Property="Background">
                                                        <Setter.Value>
                                                            <SolidColorBrush Color="{StaticResource Color.Brand.Primary}" Opacity="0.1"/>
                                                        </Setter.Value>
                                                    </Setter>
                                                    <Setter Property="Foreground" Value="{StaticResource Brush.Text.Primary}" />
                                                    <Setter Property="FontWeight" Value="Bold" />
                                                </Trigger>
                                                <Trigger Property="IsSelected" Value="False">
                                                    <Setter Property="Foreground" Value="{StaticResource Brush.Text.Muted}" />
                                                </Trigger>
                                                <Trigger Property="IsMouseOver" Value="True">
                                                    <Setter TargetName="Border" Property="Background">
                                                        <Setter.Value>
                                                            <SolidColorBrush Color="{StaticResource Color.Brand.Primary}" Opacity="0.05"/>
                                                        </Setter.Value>
                                                    </Setter>
                                                </Trigger>
                                            </ControlTemplate.Triggers>
                                        </ControlTemplate>
                                    </Setter.Value>
                                </Setter>
                            </Style>
                        </TabControl.Resources>

                        <!-- Hex View -->
                        <TabItem Header="BINARY (HEX)">
                            <Grid Background="Black">
                                <Grid.RowDefinitions>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="*"/>
                                </Grid.RowDefinitions>
                                <TextBlock Text="BINARY DATA STREAM" Foreground="{StaticResource Brush.Text.Primary}" FontWeight="Bold" FontSize="12" Margin="10,10,10,10"/>

                                <!-- Virtualized Hex Viewer -->
                                <ListBox Grid.Row="1" ItemsSource="{Binding HexData}" Background="Black" BorderThickness="0" VirtualizingPanel.IsVirtualizing="True" VirtualizingPanel.VirtualizationMode="Recycling" VirtualizingPanel.ScrollUnit="Pixel" ScrollViewer.HorizontalScrollBarVisibility="Disabled" Margin="10,0,10,10">
                                    <ListBox.ItemContainerStyle>
                                        <Style TargetType="ListBoxItem">
                                            <Setter Property="Padding" Value="0"/>
                                            <Setter Property="Margin" Value="0,1"/>
                                            <Setter Property="BorderThickness" Value="0"/>
                                            <Setter Property="Background" Value="Transparent"/>
                                            <Setter Property="Focusable" Value="False"/>
                                            <Setter Property="Template">
                                                <Setter.Value>
                                                    <ControlTemplate TargetType="ListBoxItem">
                                                        <ContentPresenter />
                                                    </ControlTemplate>
                                                </Setter.Value>
                                            </Setter>
                                        </Style>
                                    </ListBox.ItemContainerStyle>
                                    <ListBox.ItemTemplate>
                                        <DataTemplate>
                                            <Grid>
                                                <Grid.ColumnDefinitions>
                                                    <ColumnDefinition Width="90"/>
                                                    <ColumnDefinition Width="400"/>
                                                    <ColumnDefinition Width="20"/>
                                                    <ColumnDefinition Width="*"/>
                                                </Grid.ColumnDefinitions>

                                                <!-- Offset -->
                                                <TextBlock Text="{Binding Offset, StringFormat={}{0:X8}}" Foreground="{StaticResource Brush.Action.Primary}" FontFamily="{StaticResource MonoFont}" FontSize="11" Margin="0,0,10,0" VerticalAlignment="Center" Opacity="0.8"/>

                                                <!-- Hex Bytes -->
                                                <ItemsControl Grid.Column="1" ItemsSource="{Binding Items}">
                                                    <ItemsControl.ItemsPanel>
                                                        <ItemsPanelTemplate>
                                                            <StackPanel Orientation="Horizontal"/>
                                                        </ItemsPanelTemplate>
                                                    </ItemsControl.ItemsPanel>
                                                    <ItemsControl.ItemTemplate>
                                                        <DataTemplate>
                                                            <TextBlock Text="{Binding Value, StringFormat={}{0:X2}}" FontFamily="{StaticResource MonoFont}" FontSize="11" Margin="0,0,8,0">
                                                                <TextBlock.Style>
                                                                    <Style TargetType="TextBlock">
                                                                        <Setter Property="Foreground" Value="{StaticResource Brush.Text.Muted}"/>
                                                                        <Setter Property="Background" Value="Transparent"/>
                                                                        <Style.Triggers>
                                                                            <DataTrigger Binding="{Binding IsHighlighted}" Value="True">
                                                                                <Setter Property="Background" Value="{StaticResource Brush.Action.Primary}"/>
                                                                                <Setter Property="Foreground" Value="Black"/>
                                                                                <Setter Property="FontWeight" Value="Bold"/>
                                                                            </DataTrigger>
                                                                        </Style.Triggers>
                                                                    </Style>
                                                                </TextBlock.Style>
                                                            </TextBlock>
                                                        </DataTemplate>
                                                    </ItemsControl.ItemTemplate>
                                                </ItemsControl>

                                                <!-- Separator -->
                                                <TextBlock Grid.Column="2" Text="|" Foreground="{StaticResource Brush.Panel.Border}" FontFamily="{StaticResource MonoFont}" FontSize="11" VerticalAlignment="Center" Margin="5,0"/>

                                                <!-- ASCII Text -->
                                                <TextBlock Grid.Column="3" FontFamily="{StaticResource MonoFont}" FontSize="11" Foreground="{StaticResource Brush.Text.Muted}" VerticalAlignment="Center">
                                                    <TextBlock.Text>
                                                        <MultiBinding StringFormat="{}{0}">
                                                            <Binding Path="AsciiText"/>
                                                        </MultiBinding>
                                                    </TextBlock.Text>
                                                </TextBlock>
                                            </Grid>
                                        </DataTemplate>
                                    </ListBox.ItemTemplate>
                                </ListBox>
                            </Grid>
                        </TabItem>

                        <!-- Raw Text View -->
                        <TabItem Header="RAW TEXT">
                            <Grid Background="{StaticResource Brush.Panel.Background}">
                                <Grid.RowDefinitions>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="*"/>
                                </Grid.RowDefinitions>
                                <TextBlock Text="RAW FILE CONTENT (UTF-8)" Foreground="{StaticResource Brush.Text.Primary}" FontWeight="Bold" FontSize="12" Margin="10,10,10,10"/>
                                <ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Auto" Margin="10,0,10,10">
                                    <RichTextBox x:Name="RawTextRichTextBox" FontFamily="{StaticResource MonoFont}" FontSize="11" Foreground="{StaticResource Brush.Text.Primary}" Background="Transparent" BorderThickness="0" IsReadOnly="True" IsDocumentEnabled="True">
                                        <RichTextBox.Resources>
                                            <Style TargetType="{x:Type Paragraph}">
                                                <Setter Property="Margin" Value="0"/>
                                                <Setter Property="FontFamily" Value="{StaticResource MonoFont}"/>
                                                <Setter Property="FontSize" Value="11"/>
                                            </Style>
                                            <Style TargetType="{x:Type Run}">
                                                <Setter Property="FontFamily" Value="{StaticResource MonoFont}"/>
                                                <Setter Property="FontSize" Value="11"/>
                                            </Style>
                                        </RichTextBox.Resources>
                                    </RichTextBox>
                                </ScrollViewer>
                            </Grid>
                        </TabItem>

                        <!-- Structure View -->
                        <TabItem Header="STRUCTURE" Visibility="{Binding HasStructure, Converter={StaticResource BooleanToVisibilityConverter}}">
                            <Grid Background="{StaticResource Brush.Panel.Background}">
                                <Grid.RowDefinitions>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="*"/>
                                </Grid.RowDefinitions>
                                <TextBlock Text="FILE STRUCTURE ANALYSIS" Foreground="{StaticResource Brush.Text.Primary}" FontWeight="Bold" FontSize="12" Margin="10,10,10,10"/>
                                <TreeView Grid.Row="1" ItemsSource="{Binding StructureRoot}" Background="Transparent" BorderThickness="0" Margin="10,0,10,10">
                                    <TreeView.ItemTemplate>
                                        <HierarchicalDataTemplate ItemsSource="{Binding Children}">
                                            <StackPanel Orientation="Horizontal">
                                                <TextBlock Text="{Binding Name}" Foreground="#4EC9B0" FontWeight="Bold"/>
                                                <TextBlock Text=": " Foreground="Gray"/>
                                                <TextBlock Text="{Binding Value}" Foreground="#DCDCAA"/>
                                                <TextBlock Text="  (Offset: 0x" Foreground="Gray" Margin="10,0,0,0"/>
                                                <TextBlock Text="{Binding Offset, StringFormat=X}" Foreground="Gray"/>
                                                <TextBlock Text=")" Foreground="Gray"/>
                                            </StackPanel>
                                        </HierarchicalDataTemplate>
                                    </TreeView.ItemTemplate>
                                    <TreeView.ItemContainerStyle>
                                        <Style TargetType="TreeViewItem">
                                            <Setter Property="IsExpanded" Value="True"/>
                                            <Setter Property="Foreground" Value="{StaticResource Brush.Text.Primary}"/>
                                        </Style>
                                    </TreeView.ItemContainerStyle>
                                </TreeView>
                            </Grid>
                        </TabItem>
                    </TabControl>

                    <!-- Navigation Controls -->
                    <Border Grid.Row="2" Background="#111" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="0,1,0,0" Padding="10">
                        <StackPanel Orientation="Horizontal" HorizontalAlignment="Center">
                            <Button Command="{Binding NavigateToStartCommand}" Content="⏮ Start" Padding="10,5" Margin="0,0,5,0" FontSize="11"/>
                            <Button Command="{Binding NavigatePreviousCommand}" Content="◀ Previous" Padding="10,5" Margin="0,0,5,0" FontSize="11" IsEnabled="{Binding CanNavigatePrevious}"/>
                            <Button Command="{Binding NavigateNextCommand}" Content="Next ▶" Padding="10,5" Margin="0,0,5,0" FontSize="11" IsEnabled="{Binding CanNavigateNext}"/>
                            <Button Command="{Binding NavigateToEndCommand}" Content="End ⏭" Padding="10,5" FontSize="11"/>
                        </StackPanel>
                    </Border>
                </Grid>
            </Border>

            <!-- Right Panel -->
            <Border Grid.Column="2" Background="{StaticResource Brush.Panel.Background}" BorderBrush="{StaticResource Brush.Action.Primary}" BorderThickness="1,0,0,0" Padding="10">
                <StackPanel>
                    <TextBlock Text="DISCOVERY ANALYTICS" FontSize="10" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,0,10"/>

                    <StackPanel Orientation="Horizontal" Margin="0,0,0,5">
                        <TextBlock Text="Matches Found: " Foreground="{StaticResource Brush.Text.Primary}"/>
                        <TextBlock Text="{Binding SearchCount, StringFormat={}{0:N0}}" Foreground="{StaticResource Brush.Status.Success}" FontWeight="Bold"/>
                    </StackPanel>
                    <ListBox ItemsSource="{Binding SearchResults}" Height="200" Background="Transparent" BorderBrush="{StaticResource Brush.Panel.Border}" MouseDoubleClick="SearchResults_MouseDoubleClick">
                        <ListBox.ItemTemplate>
                            <DataTemplate>
                                <TextBlock Text="{Binding StringFormat={}0x{0:X8}}" FontFamily="Consolas" Foreground="{StaticResource Brush.Status.Success}"/>
                            </DataTemplate>
                        </ListBox.ItemTemplate>
                    </ListBox>
                </StackPanel>
            </Border>

        </Grid>
    </Grid>
</UserControl>


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWS\ANALYSISWORKSPACEVIEW.XAML.CS CODE IS BELOW
using System.Windows.Controls;
using System.Windows.Input;
using DataSpecter.UI.ViewModels;
using System.ComponentModel;

namespace DataSpecter.UI.Views
{
    public partial class AnalysisWorkspaceView : UserControl
    {
        public AnalysisWorkspaceView()
        {
            InitializeComponent();
            DataContextChanged += OnDataContextChanged;
        }

        private void OnDataContextChanged(object sender, System.Windows.DependencyPropertyChangedEventArgs e)
        {
            if (e.OldValue is AnalysisWorkspaceViewModel oldViewModel)
            {
                oldViewModel.PropertyChanged -= ViewModel_PropertyChanged;
            }

            if (e.NewValue is AnalysisWorkspaceViewModel newViewModel)
            {
                newViewModel.PropertyChanged += ViewModel_PropertyChanged;
                UpdateTextDocument(newViewModel.TextDocument);
            }
        }

        private void ViewModel_PropertyChanged(object? sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(AnalysisWorkspaceViewModel.TextDocument))
            {
                if (sender is AnalysisWorkspaceViewModel viewModel)
                {
                    UpdateTextDocument(viewModel.TextDocument);
                }
            }
        }

        private void UpdateTextDocument(System.Windows.Documents.FlowDocument? document)
        {
            if (document != null)
            {
                // Check if the document is already assigned to this RichTextBox
                if (RawTextRichTextBox.Document == document)
                {
                    return; // Already assigned, nothing to do
                }
                
                // Create a new FlowDocument and copy the content to avoid the 
                // "Document already belongs to another RichTextBox" exception
                // This happens when navigating between views with the same ViewModel instance
                var newDocument = new System.Windows.Documents.FlowDocument();
                
                // Copy blocks from the source document to the new document
                var blocksToAdd = new System.Collections.Generic.List<System.Windows.Documents.Block>();
                foreach (var block in document.Blocks)
                {
                    blocksToAdd.Add(block);
                }
                
                // Remove blocks from source and add to new document
                document.Blocks.Clear();
                foreach (var block in blocksToAdd)
                {
                    newDocument.Blocks.Add(block);
                }
                
                RawTextRichTextBox.Document = newDocument;
            }
        }

        private void SearchResults_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            if (sender is ListBox listBox && listBox.SelectedItem is long offset)
            {
                if (DataContext is AnalysisWorkspaceViewModel viewModel)
                {
                    viewModel.NavigateToOffsetCommand.Execute(offset);
                }
            }
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWS\ANOMALYDETAILSVIEW.XAML CODE IS BELOW
<UserControl x:Class="DataSpecter.UI.Views.AnomalyDetailsView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008" mc:Ignorable="d" d:DesignHeight="450" d:DesignWidth="800">
    <Grid>
        <Grid.Background>
            <RadialGradientBrush GradientOrigin="0.5,0.5" Center="0.5,0.5" RadiusX="1.2" RadiusY="1.2">
                <GradientStop Color="#1a0505" Offset="0.0"/>
                <GradientStop Color="#000000" Offset="1.0"/>
            </RadialGradientBrush>
        </Grid.Background>

        <Path Data="M12,2A9,9 0 0,0 3,11C3,14.03 4.53,16.82 7,18.47V22H9V19H11V22H13V19H15V22H17V18.46C19.47,16.81 21,14 21,11A9,9 0 0,0 12,2M8,11A2,2 0 0,1 10,13A2,2 0 0,1 8,15A2,2 0 0,1 6,13A2,2 0 0,1 8,11M16,11A2,2 0 0,1 18,13A2,2 0 0,1 16,15A2,2 0 0,1 14,13A2,2 0 0,1 16,11M12,14H14V17H10V14H12Z" Fill="#33FF0000" Stretch="Uniform" Width="450" Height="450" HorizontalAlignment="Center" VerticalAlignment="Center" Opacity="0.08" IsHitTestVisible="False">
            <Path.Effect>
                <DropShadowEffect Color="#FF0000" BlurRadius="50" ShadowDepth="0" Opacity="0.5"/>
            </Path.Effect>
        </Path>

        <Canvas x:Name="ParticleCanvas" IsHitTestVisible="False" ClipToBounds="True"/>

        <Grid Margin="20">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="*"/>
                <RowDefinition Height="Auto"/>
            </Grid.RowDefinitions>

            <!-- Header -->
            <StackPanel Grid.Row="0" Margin="0,0,0,20">
                <TextBlock Text="ANOMALY ISOLATION" FontSize="24" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}"/>
                <TextBlock Text="Longest Repeated Substring (LRS) Detected" Foreground="{StaticResource Brush.Text.Muted}"/>
            </StackPanel>

            <!-- Stats -->
            <Border Grid.Row="1" Background="{StaticResource Brush.Panel.Background}" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="1" Padding="15" Margin="0,0,0,20">
                <UniformGrid Columns="3">
                    <StackPanel>
                        <TextBlock Text="OFFSET" FontSize="10" Foreground="{StaticResource Brush.Text.Muted}" FontWeight="Bold"/>
                        <TextBlock Text="{Binding Offset, StringFormat={}0x{0:X}}" FontSize="16" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}"/>
                    </StackPanel>
                    <StackPanel>
                        <TextBlock Text="LENGTH" FontSize="10" Foreground="{StaticResource Brush.Text.Muted}" FontWeight="Bold"/>
                        <TextBlock Text="{Binding Length, StringFormat={}{0:N0} Bytes}" FontSize="16" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}"/>
                    </StackPanel>
                    <StackPanel>
                        <TextBlock Text="SOURCE FILE" FontSize="10" Foreground="{StaticResource Brush.Text.Muted}" FontWeight="Bold"/>
                        <TextBlock Text="{Binding File.Name}" FontSize="16" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}"/>
                    </StackPanel>
                </UniformGrid>
            </Border>

            <!-- Split View -->
            <Grid Grid.Row="2">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="20"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>

                <!-- Hex -->
                <Border Grid.Column="0" Background="Black" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="1">
                    <Grid>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="*"/>
                        </Grid.RowDefinitions>
                        <Border Background="#111" Padding="10">
                            <TextBlock Text="HEX REPRESENTATION" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}"/>
                        </Border>
                        <ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Auto" Padding="10">
                            <ItemsControl ItemsSource="{Binding HexData}">
                                <ItemsControl.ItemsPanel>
                                    <ItemsPanelTemplate>
                                        <WrapPanel />
                                    </ItemsPanelTemplate>
                                </ItemsControl.ItemsPanel>
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <Border Margin="2" Padding="4" Background="#111">
                                            <TextBlock Text="{Binding StringFormat={}{0:X2}}" Foreground="{StaticResource Brush.Text.Muted}" FontFamily="Consolas"/>
                                        </Border>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                            </ItemsControl>
                        </ScrollViewer>
                    </Grid>
                </Border>

                <!-- Text -->
                <Border Grid.Column="2" Background="{StaticResource Brush.Panel.Background}" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="1">
                    <Grid>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="*"/>
                        </Grid.RowDefinitions>
                        <Border Background="#222" Padding="10">
                            <TextBlock Text="TEXT REPRESENTATION" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}"/>
                        </Border>
                        <ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Auto" Padding="10">
                            <TextBlock Text="{Binding TextData}" FontFamily="Consolas" Foreground="{StaticResource Brush.Text.Primary}" TextWrapping="Wrap"/>
                        </ScrollViewer>
                    </Grid>
                </Border>
            </Grid>

            <!-- Action Bar -->
            <StackPanel Grid.Row="3" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,20,0,0">
                <Button Command="{Binding DataContext.NavigateToAnalysisCommand, RelativeSource={RelativeSource AncestorType=Window}}" Content="Back to Analysis"/>
            </StackPanel>

        </Grid>
    </Grid>
</UserControl>


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWS\ANOMALYDETAILSVIEW.XAML.CS CODE IS BELOW
using System.Windows.Controls;

namespace DataSpecter.UI.Views
{
    public partial class AnomalyDetailsView : UserControl
    {
        public AnomalyDetailsView()
        {
            InitializeComponent();
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWS\BACKGROUNDPRESENTER.CS CODE IS BELOW
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;

namespace DataSpecter.UI.Views
{
    // A special control that mirrors everything behind it
    public class BackgroundPresenter : FrameworkElement
    {
        private static readonly FieldInfo _drawingContentOfUIElement = typeof(UIElement)
            .GetField("_drawingContent", BindingFlags.Instance | BindingFlags.NonPublic)!;

        private static readonly FieldInfo _contentOfDrawingVisual = typeof(DrawingVisual)
            .GetField("_content", BindingFlags.Instance | BindingFlags.NonPublic)!;

        private static readonly FieldInfo _offsetOfVisual = typeof(Visual)
            .GetField("_offset", BindingFlags.Instance | BindingFlags.NonPublic)!;

        private static readonly Func<UIElement, DrawingContext> _renderOpenMethod = typeof(UIElement)
            .GetMethod("RenderOpen", BindingFlags.Instance | BindingFlags.NonPublic)!
            .CreateDelegate<Func<UIElement, DrawingContext>>();

        private static readonly Action<UIElement, DrawingContext> _onRenderMethod = typeof(UIElement)
            .GetMethod("OnRender", BindingFlags.Instance | BindingFlags.NonPublic)!
            .CreateDelegate<Action<UIElement, DrawingContext>>();

        private static readonly MethodInfo _methodGetContentBounds = typeof(VisualBrush)
            .GetMethod("GetContentBounds", BindingFlags.Instance | BindingFlags.NonPublic)!;

        private readonly Stack<UIElement> _parentStack = new Stack<UIElement>();

        private static void ForceRender(UIElement target)
        {
            if (target == null) return;
            try
            {
                using (DrawingContext drawingContext = _renderOpenMethod(target))
                {
                    _onRenderMethod.Invoke(target, drawingContext);
                }
            }
            catch { /* Ignore render errors during layout updates */ }
        }

        private static void DrawVisual(DrawingContext drawingContext, Visual visual, Point relatedXY, Size renderSize)
        {
            if (visual == null) return;
            try
            {
                var visualBrush = new VisualBrush(visual) { Stretch = Stretch.None };
                var visualOffset = (Vector)_offsetOfVisual.GetValue(visual)!;

                // Invoke private GetContentBounds
                object[] args = new object[] { null }; // out Rect
                _methodGetContentBounds.Invoke(visualBrush, args);
                Rect contentBounds = (Rect)args[0];

                relatedXY -= visualOffset;

                drawingContext.DrawRectangle(
                    visualBrush, null,
                    new Rect(relatedXY.X + contentBounds.X, relatedXY.Y + contentBounds.Y, contentBounds.Width, contentBounds.Height));
            }
            catch { }
        }

        protected override Geometry GetLayoutClip(Size layoutSlotSize)
        {
            return new RectangleGeometry(new Rect(0, 0, ActualWidth, ActualHeight));
        }

        protected override void OnVisualParentChanged(DependencyObject oldParentObject)
        {
            base.OnVisualParentChanged(oldParentObject);

            if (oldParentObject is UIElement oldParent)
                oldParent.LayoutUpdated -= ParentLayoutUpdated;

            if (VisualTreeHelper.GetParent(this) is UIElement newParent)
                newParent.LayoutUpdated += ParentLayoutUpdated;
        }

        private void ParentLayoutUpdated(object sender, EventArgs e)
        {
            // Force this element to re-render when the parent changes
            ForceRender(this);
        }

        protected override void OnRender(DrawingContext drawingContext)
        {
            // Draw everything behind this element onto this element
            DrawBackground(drawingContext, this, _parentStack, 10, false);
        }

        private static void DrawBackground(
            DrawingContext drawingContext, UIElement self,
            Stack<UIElement> parentStackStorage,
            int maxDepth,
            bool throwExceptionIfParentArranging)
        {
            var parent = VisualTreeHelper.GetParent(self) as UIElement;

            // 1. Walk up the tree to find ancestors
            while (parent != null && parentStackStorage.Count < maxDepth)
            {
                if (!parent.IsVisible) { parentStackStorage.Clear(); return; }
                parentStackStorage.Push(parent);
                parent = VisualTreeHelper.GetParent(parent) as UIElement;
            }

            var selfRect = new Rect(0, 0, self.RenderSize.Width, self.RenderSize.Height);

            // 2. Walk down and draw ancestors + siblings
            while (parentStackStorage.Count > 0)
            {
                var currentParent = parentStackStorage.Pop();
                UIElement breakElement = (parentStackStorage.Count > 0) ? parentStackStorage.Peek() : self;

                // Draw Parent's own content
                if (_drawingContentOfUIElement.GetValue(currentParent) is object parentDrawingContent)
                {
                    var drawingVisual = new DrawingVisual();
                    _contentOfDrawingVisual.SetValue(drawingVisual, parentDrawingContent);
                    var parentRelatedXY = currentParent.TranslatePoint(new Point(0, 0), self);
                    DrawVisual(drawingContext, drawingVisual, parentRelatedXY, currentParent.RenderSize);
                }

                // Draw Siblings (Children of parent that are behind 'self')
                if (currentParent is Panel parentPanel)
                {
                    foreach (UIElement child in parentPanel.Children)
                    {
                        if (child == breakElement) break; // Stop when we reach the branch containing 'self'

                        if (child.IsVisible)
                        {
                            var childRelatedXY = child.TranslatePoint(new Point(0, 0), self);
                            var childRect = new Rect(childRelatedXY, child.RenderSize);

                            if (selfRect.IntersectsWith(childRect))
                            {
                                DrawVisual(drawingContext, child, childRelatedXY, child.RenderSize);
                            }
                        }
                    }
                }
            }
        }
    }
}

C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWS\DASHBOARDVIEW.XAML CODE IS BELOW
<UserControl x:Class="DataSpecter.UI.Views.DashboardView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:vm="clr-namespace:DataSpecter.UI.ViewModels" mc:Ignorable="d" d:DesignHeight="600" d:DesignWidth="900" Loaded="UserControl_Loaded">

    <UserControl.Resources>
        <StreamGeometry x:Key="StarIcon">
            M 10,0 L 12.5,7.5 L 20,10 L 12.5,12.5 L 10,20 L 7.5,12.5 L 0,10 L 7.5,7.5 Z
        </StreamGeometry>

        <Style x:Key="LoadingSpinnerStyle" TargetType="Control">
            <Setter Property="Width" Value="20"/>
            <Setter Property="Height" Value="20"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Control">
                        <Grid RenderTransformOrigin="0.5,0.5">
                            <Grid.RenderTransform>
                                <RotateTransform x:Name="SpinTransform" Angle="0"/>
                            </Grid.RenderTransform>
                            <Path Data="M 10 0 A 10 10 0 0 1 20 10" Stroke="{StaticResource Brush.Text.Primary}" StrokeThickness="2" Width="20" Height="20" Stretch="None" HorizontalAlignment="Left" VerticalAlignment="Top"/>
                        </Grid>
                        <ControlTemplate.Triggers>
                            <Trigger Property="Visibility" Value="Visible">
                                <Trigger.EnterActions>
                                    <BeginStoryboard>
                                        <Storyboard>
                                            <DoubleAnimation Storyboard.TargetName="SpinTransform" Storyboard.TargetProperty="Angle" From="0" To="360" Duration="0:0:1" RepeatBehavior="Forever"/>
                                        </Storyboard>
                                    </BeginStoryboard>
                                </Trigger.EnterActions>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </UserControl.Resources>

    <Grid>
        <Grid.Background>
            <RadialGradientBrush GradientOrigin="0.5,0.5" Center="0.5,0.5" RadiusX="1.2" RadiusY="1.2">
                <GradientStop Color="#1a0505" Offset="0.0"/>
                <GradientStop Color="#000000" Offset="1.0"/>
            </RadialGradientBrush>
        </Grid.Background>

        <Path Data="M12,2A9,9 0 0,0 3,11C3,14.03 4.53,16.82 7,18.47V22H9V19H11V22H13V19H15V22H17V18.46C19.47,16.81 21,14 21,11A9,9 0 0,0 12,2M8,11A2,2 0 0,1 10,13A2,2 0 0,1 8,15A2,2 0 0,1 6,13A2,2 0 0,1 8,11M16,11A2,2 0 0,1 18,13A2,2 0 0,1 16,15A2,2 0 0,1 14,13A2,2 0 0,1 16,11M12,14H14V17H10V14H12Z" Fill="#33FF0000" Stretch="Uniform" Width="450" Height="450" HorizontalAlignment="Center" VerticalAlignment="Center" Opacity="0.08" IsHitTestVisible="False">
            <Path.Effect>
                <DropShadowEffect Color="#FF0000" BlurRadius="50" ShadowDepth="0" Opacity="0.5"/>
            </Path.Effect>
        </Path>

        <Canvas x:Name="ParticleCanvas" IsHitTestVisible="False" ClipToBounds="True"/>

        <ScrollViewer VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Disabled">
            <StackPanel Margin="20">

                <TextBlock Text="Data Ingestion" FontSize="24" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}">
                    <TextBlock.Effect>
                        <DropShadowEffect Color="#FF3333" BlurRadius="15" ShadowDepth="0" Opacity="0.5"/>
                    </TextBlock.Effect>
                </TextBlock>
                <TextBlock Text="Upload and index forensic evidence files." Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,0,20"/>

                <UniformGrid Columns="3" Margin="0,0,0,20">
                    <ContentControl Style="{StaticResource GlassPanel}" Margin="0,0,10,0">
                        <StackPanel>
                            <TextBlock Text="TOTAL EVIDENCE" FontSize="10" FontWeight="Regular" Foreground="{StaticResource Brush.Text.Muted}"/>
                            <TextBlock Text="{Binding TotalEvidence}" FontSize="24" FontWeight="Regular" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,5,0,0"/>
                        </StackPanel>
                    </ContentControl>

                    <ContentControl Style="{StaticResource GlassPanel}" Margin="0,0,10,0">
                        <StackPanel>
                            <TextBlock Text="FULLY INDEXED" FontSize="10" FontWeight="Regular" Foreground="{StaticResource Brush.Text.Muted}"/>
                            <TextBlock Text="{Binding FullyIndexed}" FontSize="24" FontWeight="Regular" Foreground="{StaticResource Brush.Status.Success}" Margin="0,5,0,0"/>
                        </StackPanel>
                    </ContentControl>

                    <ContentControl Style="{StaticResource GlassPanel}">
                        <StackPanel>
                            <TextBlock Text="INDEXING STRATEGY" FontSize="10" FontWeight="Regular" Foreground="{StaticResource Brush.Text.Muted}"/>
                            <TextBlock Text="{Binding IndexingStrategy}" FontSize="18" FontWeight="Regular" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,5,0,0"/>
                        </StackPanel>
                    </ContentControl>
                </UniformGrid>

                <Grid Height="300">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>

                    <ContentControl Grid.Column="0" Style="{StaticResource GlassPanel}" Margin="0,0,10,0" AllowDrop="True" Drop="Border_Drop">
                        <StackPanel VerticalAlignment="Center" HorizontalAlignment="Center">
                            <TextBlock FontFamily="./Fonts/#Manrope" Text="Drop evidence files here" Foreground="{StaticResource Brush.Text.Primary}" FontWeight="Regular" HorizontalAlignment="Center"/>
                            <TextBlock FontFamily="./Fonts/#Manrope" Text="or click to browse" Foreground="{StaticResource Brush.Text.Muted}" FontSize="12" HorizontalAlignment="Center"/>
                            <Button Command="{Binding UploadFilesCommand}" Content="📂  BROWSE FILES" Margin="0,10,0,0" Padding="15,8" FontWeight="Bold" FontSize="12"/>
                        </StackPanel>
                    </ContentControl>

                    <ContentControl Grid.Column="1" Style="{StaticResource GlassPanel}">
                        <Grid>
                            <Grid.RowDefinitions>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="*"/>
                            </Grid.RowDefinitions>
                            <TextBlock Text="RECENT INGESTIONS" FontSize="14" FontWeight="Regular" Foreground="{StaticResource Brush.Text.Primary}" Margin="10"/>

                            <ListBox Grid.Row="1" ItemsSource="{Binding Files}" Background="Transparent" BorderThickness="0" Margin="0,10,0,0">
                                <ListBox.ItemContainerStyle>
                                    <Style TargetType="ListBoxItem">
                                        <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
                                        <Setter Property="Padding" Value="5"/>
                                        <Setter Property="Margin" Value="0,0,0,5"/>
                                        <Setter Property="Background" Value="Transparent"/>
                                        <Setter Property="Template">
                                            <Setter.Value>
                                                <ControlTemplate TargetType="ListBoxItem">
                                                    <Border Background="{TemplateBinding Background}" CornerRadius="4" Padding="{TemplateBinding Padding}">
                                                        <ContentPresenter/>
                                                    </Border>
                                                </ControlTemplate>
                                            </Setter.Value>
                                        </Setter>
                                        <Style.Triggers>
                                            <Trigger Property="IsMouseOver" Value="True">
                                                <Setter Property="Background" Value="#1AFFFFFF"/>
                                            </Trigger>
                                        </Style.Triggers>
                                    </Style>
                                </ListBox.ItemContainerStyle>
                                <ListBox.ItemTemplate>
                                    <DataTemplate>
                                        <Grid Margin="5">
                                            <Grid.ColumnDefinitions>
                                                <ColumnDefinition Width="*"/>
                                                <ColumnDefinition Width="Auto"/>
                                                <ColumnDefinition Width="120"/>
                                            </Grid.ColumnDefinitions>
                                            <StackPanel Grid.Column="0" VerticalAlignment="Center">
                                                <TextBlock Text="{Binding Name}" Foreground="{StaticResource Brush.Text.Primary}" FontWeight="SemiBold" FontSize="16"/>
                                                <TextBlock Text="{Binding Path}" Foreground="{StaticResource Brush.Text.Muted}" FontSize="12" Margin="0,2,0,0"/>
                                                <StackPanel Margin="0,8,0,0">
                                                    <StackPanel.Style>
                                                        <Style TargetType="StackPanel">
                                                            <Setter Property="Visibility" Value="Collapsed"/>
                                                            <Style.Triggers>
                                                                <DataTrigger Binding="{Binding Status}" Value="indexing">
                                                                    <Setter Property="Visibility" Value="Visible"/>
                                                                </DataTrigger>
                                                            </Style.Triggers>
                                                        </Style>
                                                    </StackPanel.Style>
                                                    <TextBlock Foreground="{StaticResource Brush.Text.Primary}" FontSize="11" Margin="0,0,0,3">
                                                        <Run Text="{Binding IndexingStage}" FontWeight="Bold"/>
                                                        <Run Text=" - "/>
                                                        <Run Text="{Binding IndexingDetails}" Foreground="{StaticResource Brush.Text.Muted}"/>
                                                    </TextBlock>
                                                    <ProgressBar Value="{Binding IndexingProgress}" Maximum="100" Height="6" Background="#333" Foreground="{StaticResource Brush.Action.Primary}"/>
                                                </StackPanel>
                                                <StackPanel Orientation="Horizontal" Margin="0,5,0,0">
                                                    <StackPanel.Style>
                                                        <Style TargetType="StackPanel">
                                                            <Setter Property="Visibility" Value="Collapsed"/>
                                                            <Style.Triggers>
                                                                <DataTrigger Binding="{Binding Status}" Value="indexed">
                                                                    <Setter Property="Visibility" Value="Visible"/>
                                                                </DataTrigger>
                                                            </Style.Triggers>
                                                        </Style>
                                                    </StackPanel.Style>
                                                    <Border Background="#222" CornerRadius="3" Padding="6,2" Margin="0,0,10,0">
                                                        <TextBlock FontSize="11" Foreground="#AAA">
                                                            <Run Text="SA: " FontWeight="Bold"/>
                                                            <Run Text="{Binding SuffixArrayCount, StringFormat=N0}"/>
                                                            <Run Text=" ("/>
                                                            <Run Text="{Binding SuffixArrayTime.TotalMilliseconds, Mode=OneWay, StringFormat=F0}"/>
                                                            <Run Text="ms)"/>
                                                        </TextBlock>
                                                    </Border>
                                                    <Border Background="#222" CornerRadius="3" Padding="6,2">
                                                        <TextBlock FontSize="11" Foreground="#AAA">
                                                            <Run Text="LCP: " FontWeight="Bold"/>
                                                            <Run Text="{Binding LcpArrayCount, StringFormat=N0}"/>
                                                            <Run Text=" ("/>
                                                            <Run Text="{Binding LcpArrayTime.TotalMilliseconds, Mode=OneWay, StringFormat=F0}"/>
                                                            <Run Text="ms)"/>
                                                        </TextBlock>
                                                    </Border>
                                                </StackPanel>
                                            </StackPanel>
                                            <TextBlock Grid.Column="1" Text="{Binding Status}" Foreground="{StaticResource Brush.Status.Success}" VerticalAlignment="Center" FontSize="12" FontWeight="Bold" Margin="20,0,20,0"/>
                                            <Grid Grid.Column="2" HorizontalAlignment="Right" VerticalAlignment="Center">
                                                <Button Content="Index" Command="{Binding DataContext.IndexFileCommand, RelativeSource={RelativeSource AncestorType=UserControl}}" CommandParameter="{Binding}" Padding="15,5" FontSize="12">
                                                    <Button.Style>
                                                        <Style TargetType="Button" BasedOn="{StaticResource {x:Type Button}}">
                                                            <Setter Property="Visibility" Value="Visible"/>
                                                            <Style.Triggers>
                                                                <DataTrigger Binding="{Binding Status}" Value="indexing">
                                                                    <Setter Property="Visibility" Value="Collapsed"/>
                                                                </DataTrigger>
                                                                <DataTrigger Binding="{Binding Status}" Value="indexed">
                                                                    <Setter Property="Visibility" Value="Collapsed"/>
                                                                </DataTrigger>
                                                            </Style.Triggers>
                                                        </Style>
                                                    </Button.Style>
                                                </Button>
                                                <Control>
                                                    <Control.Style>
                                                        <Style TargetType="Control" BasedOn="{StaticResource LoadingSpinnerStyle}">
                                                            <Setter Property="Visibility" Value="Collapsed"/>
                                                            <Style.Triggers>
                                                                <DataTrigger Binding="{Binding Status}" Value="indexing">
                                                                    <Setter Property="Visibility" Value="Visible"/>
                                                                </DataTrigger>
                                                            </Style.Triggers>
                                                        </Style>
                                                    </Control.Style>
                                                </Control>
                                                <Border Background="{StaticResource Brush.Status.Success}" CornerRadius="4" Padding="10,5">
                                                    <TextBlock Text="READY" Foreground="Black" FontWeight="Bold" FontSize="10"/>
                                                    <Border.Style>
                                                        <Style TargetType="Border">
                                                            <Setter Property="Visibility" Value="Collapsed"/>
                                                            <Style.Triggers>
                                                                <DataTrigger Binding="{Binding Status}" Value="indexed">
                                                                    <Setter Property="Visibility" Value="Visible"/>
                                                                </DataTrigger>
                                                            </Style.Triggers>
                                                        </Style>
                                                    </Border.Style>
                                                </Border>
                                            </Grid>
                                        </Grid>
                                    </DataTemplate>
                                </ListBox.ItemTemplate>
                            </ListBox>
                        </Grid>
                    </ContentControl>
                </Grid>
            </StackPanel>
        </ScrollViewer>
    </Grid>
</UserControl>

C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWS\DASHBOARDVIEW.XAML.CS CODE IS BELOW
using System;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Shapes;

namespace DataSpecter.UI.Views
{
    public partial class DashboardView : UserControl
    {
        private readonly Random _random = new Random();

        public DashboardView()
        {
            InitializeComponent();
        }

        private void UserControl_Loaded(object sender, RoutedEventArgs e)
        {
            if (ParticleCanvas.Children.Count == 0)
            {
                InitParticles(50);
            }
        }

        private void InitParticles(int count)
        {
            double width = this.ActualWidth > 0 ? this.ActualWidth : 800;
            double height = this.ActualHeight > 0 ? this.ActualHeight : 600;

            // Get the geometry from XAML resources
            var starGeometry = (Geometry)FindResource("StarIcon");

            for (int i = 0; i < count; i++)
            {
                // 1. Create the particle (Using Path for the Star Shape)
                var particle = new Path
                {
                    Data = starGeometry,
                    Fill = new SolidColorBrush(GetRandomCyberColor()),
                    Opacity = 0, // Start invisible
                    Stretch = Stretch.Uniform,
                    Width = _random.Next(5, 15),
                    Height = _random.Next(5, 15),
                    RenderTransformOrigin = new Point(0.5, 0.5)
                };

                // Create a TransformGroup so we can Rotate AND Scale
                var transformGroup = new TransformGroup();
                var scaleTransform = new ScaleTransform(1.0, 1.0);
                var rotateTransform = new RotateTransform(0); // Start angle
                transformGroup.Children.Add(scaleTransform);
                transformGroup.Children.Add(rotateTransform);
                particle.RenderTransform = transformGroup;

                // 2. Position randomly
                Canvas.SetLeft(particle, _random.NextDouble() * width);
                Canvas.SetTop(particle, _random.NextDouble() * height);

                // 3. Create Animation Storyboard
                var storyboard = new Storyboard();
                var duration = TimeSpan.FromSeconds(_random.Next(3, 8));

                // --- Opacity (Twinkle) ---
                var opacityAnim = new DoubleAnimation
                {
                    From = 0.0,
                    To = _random.NextDouble() * 0.8 + 0.2,
                    Duration = duration,
                    AutoReverse = true,
                    RepeatBehavior = RepeatBehavior.Forever,
                    BeginTime = TimeSpan.FromSeconds(_random.NextDouble() * 3)
                };

                // --- Scale (Pulse) ---
                var scaleAnim = new DoubleAnimation
                {
                    From = 1.0,
                    To = 1.8,
                    Duration = duration,
                    AutoReverse = true,
                    RepeatBehavior = RepeatBehavior.Forever
                };

                // --- Rotation (Spin) ---
                var rotateAnim = new DoubleAnimation
                {
                    From = 0,
                    To = 360,
                    Duration = TimeSpan.FromSeconds(_random.Next(10, 20)),
                    RepeatBehavior = RepeatBehavior.Forever
                };

                // Apply Animations
                Storyboard.SetTarget(opacityAnim, particle);
                Storyboard.SetTargetProperty(opacityAnim, new PropertyPath("Opacity"));

                Storyboard.SetTarget(scaleAnim, particle);
                Storyboard.SetTargetProperty(scaleAnim, new PropertyPath("RenderTransform.Children[0].ScaleX"));

                var scaleYAnim = scaleAnim.Clone();
                Storyboard.SetTarget(scaleYAnim, particle);
                Storyboard.SetTargetProperty(scaleYAnim, new PropertyPath("RenderTransform.Children[0].ScaleY"));

                Storyboard.SetTarget(rotateAnim, particle);
                Storyboard.SetTargetProperty(rotateAnim, new PropertyPath("RenderTransform.Children[1].Angle"));

                storyboard.Children.Add(opacityAnim);
                storyboard.Children.Add(scaleAnim);
                storyboard.Children.Add(scaleYAnim);
                storyboard.Children.Add(rotateAnim);

                ParticleCanvas.Children.Add(particle);
                storyboard.Begin();
            }
        }

        private Color GetRandomCyberColor()
        {
            int choice = _random.Next(0, 4);
            switch (choice)
            {
                case 0: return Color.FromRgb(255, 0, 50);      // Neon Red
                case 1: return Color.FromRgb(255, 100, 100);   // Light Red
                case 2: return Color.FromRgb(200, 0, 0);       // Dark Red
                default: return Color.FromArgb(150, 255, 255, 255); // White/Grey spark
            }
        }

        // --- Keep your existing event handlers (like GlassPanel_MouseMove) below ---
        private void GlassPanel_MouseMove(object sender, MouseEventArgs e)
        {
            if (sender is ContentControl panel)
            {
                if (panel.Template.FindName("PointerHighlightBrush", panel) is RadialGradientBrush brush)
                {
                    Point p = e.GetPosition(panel);

                    if (panel.ActualWidth > 0 && panel.ActualHeight > 0)
                    {
                        double x = p.X / panel.ActualWidth;
                        double y = p.Y / panel.ActualHeight;

                        brush.Center = new Point(x, y);
                        brush.GradientOrigin = new Point(x, y);
                    }
                }
            }
        }

        private void Border_Drop(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
            {
                string[] files = (string[])e.Data.GetData(DataFormats.FileDrop);
                
                if (files != null && files.Length > 0 && DataContext is ViewModels.DashboardViewModel viewModel)
                {
                    // Filter to only existing files
                    var existingFiles = files.Where(f => System.IO.File.Exists(f)).ToArray();
                    
                    if (existingFiles.Length > 0 && viewModel.DropFilesCommand.CanExecute(existingFiles))
                    {
                        viewModel.DropFilesCommand.Execute(existingFiles);
                    }
                }
            }
        }
    }
}

C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWS\ENTROPYANALYSISWINDOW.XAML CODE IS BELOW
<Window x:Class="DataSpecter.UI.Views.EntropyAnalysisWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:converters="clr-namespace:DataSpecter.UI.Converters" mc:Ignorable="d" Title="Entropy Analysis" Height="700" Width="1000" Background="{StaticResource Brush.Panel.Background}" WindowStartupLocation="CenterOwner" ResizeMode="CanResize">

    <Window.Resources>
        <BooleanToVisibilityConverter x:Key="BooleanToVisibilityConverter"/>
        <converters:EntropyHeightConverter x:Key="EntropyHeightConverter"/>
    </Window.Resources>

    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Header -->
        <StackPanel Grid.Row="0" Margin="0,0,0,20">
            <TextBlock Text="ENTROPY ANALYSIS" FontSize="24" FontWeight="Bold" Foreground="{StaticResource Brush.Action.Primary}"/>
            <TextBlock Text="{Binding FileName}" FontSize="14" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,5,0,0"/>
            <TextBlock Text="{Binding FileSize}" FontSize="12" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,2,0,0"/>
        </StackPanel>

        <!-- Progress -->
        <Border Grid.Row="1" Background="#111" BorderBrush="{StaticResource Brush.Action.Primary}" BorderThickness="1" Padding="15" Margin="0,0,0,20" Visibility="{Binding IsCalculating, Converter={StaticResource BooleanToVisibilityConverter}}">
            <StackPanel>
                <TextBlock Text="{Binding CalculationStatus}" Foreground="{StaticResource Brush.Text.Primary}" FontSize="12" Margin="0,0,0,10"/>
                <ProgressBar Value="{Binding CalculationProgress}" Maximum="100" Height="8" Background="#333" Foreground="{StaticResource Brush.Action.Primary}"/>
            </StackPanel>
        </Border>

        <!-- Main Content -->
        <Grid Grid.Row="2" Visibility="{Binding HasResults, Converter={StaticResource BooleanToVisibilityConverter}}">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="2*"/>
                <ColumnDefinition Width="*"/>
            </Grid.ColumnDefinitions>

            <!-- Left: Charts -->
            <Border Grid.Column="0" Background="#0a0a0a" BorderBrush="{StaticResource Brush.Action.Primary}" BorderThickness="1" Margin="0,0,10,0">
                <ScrollViewer VerticalScrollBarVisibility="Auto">
                    <StackPanel Margin="15">
                        <!-- Entropy Chart -->
                        <TextBlock Text="SHANNON ENTROPY DISTRIBUTION" FontSize="12" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,0,0,10"/>

                        <Border Height="250" Background="Black" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="1" Padding="5" Margin="0,0,0,20">
                            <Grid>
                                <!-- Entropy bars -->
                                <ItemsControl ItemsSource="{Binding EntropyData}">
                                    <ItemsControl.ItemsPanel>
                                        <ItemsPanelTemplate>
                                            <UniformGrid Rows="1"/>
                                        </ItemsPanelTemplate>
                                    </ItemsControl.ItemsPanel>
                                    <ItemsControl.ItemTemplate>
                                        <DataTemplate>
                                            <Rectangle Fill="{StaticResource Brush.Action.Primary}" VerticalAlignment="Bottom" Margin="0,0,0.5,0" ToolTip="{Binding}">
                                                <Rectangle.Height>
                                                    <MultiBinding Converter="{StaticResource EntropyHeightConverter}">
                                                        <Binding/>
                                                        <Binding RelativeSource="{RelativeSource AncestorType=Border}" Path="ActualHeight"/>
                                                    </MultiBinding>
                                                </Rectangle.Height>
                                            </Rectangle>
                                        </DataTemplate>
                                    </ItemsControl.ItemTemplate>
                                </ItemsControl>

                                <!-- Y-axis labels -->
                                <StackPanel HorizontalAlignment="Left" VerticalAlignment="Stretch" Margin="2,5,0,5">
                                    <TextBlock Text="8.0" Foreground="{StaticResource Brush.Text.Muted}" FontSize="9" FontFamily="Consolas"/>
                                    <TextBlock Text="6.0" Foreground="{StaticResource Brush.Text.Muted}" FontSize="9" FontFamily="Consolas" Margin="0,35,0,0"/>
                                    <TextBlock Text="4.0" Foreground="{StaticResource Brush.Text.Muted}" FontSize="9" FontFamily="Consolas" Margin="0,35,0,0"/>
                                    <TextBlock Text="2.0" Foreground="{StaticResource Brush.Text.Muted}" FontSize="9" FontFamily="Consolas" Margin="0,35,0,0"/>
                                    <TextBlock Text="0.0" Foreground="{StaticResource Brush.Text.Muted}" FontSize="9" FontFamily="Consolas" Margin="0,35,0,0"/>
                                </StackPanel>
                            </Grid>
                        </Border>

                        <!-- Byte Frequency Distribution -->
                        <TextBlock Text="BYTE FREQUENCY DISTRIBUTION (0x00 - 0xFF)" FontSize="12" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,0,0,10"/>

                        <Border Height="200" Background="Black" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="1" Padding="5">
                            <ItemsControl ItemsSource="{Binding ByteFrequencies}">
                                <ItemsControl.ItemsPanel>
                                    <ItemsPanelTemplate>
                                        <UniformGrid Rows="1"/>
                                    </ItemsPanelTemplate>
                                </ItemsControl.ItemsPanel>
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <Rectangle VerticalAlignment="Bottom" Margin="0,0,0.2,0" ToolTip="{Binding}">
                                            <Rectangle.Fill>
                                                <LinearGradientBrush StartPoint="0,1" EndPoint="0,0">
                                                    <GradientStop Color="#00FFAA" Offset="0"/>
                                                    <GradientStop Color="#0088FF" Offset="1"/>
                                                </LinearGradientBrush>
                                            </Rectangle.Fill>
                                            <Rectangle.Height>
                                                <MultiBinding Converter="{StaticResource EntropyHeightConverter}">
                                                    <Binding/>
                                                    <Binding RelativeSource="{RelativeSource AncestorType=Border}" Path="ActualHeight"/>
                                                </MultiBinding>
                                            </Rectangle.Height>
                                        </Rectangle>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                            </ItemsControl>
                        </Border>
                    </StackPanel>
                </ScrollViewer>
            </Border>

            <!-- Right: Statistics & Analysis -->
            <Border Grid.Column="1" Background="#0a0a0a" BorderBrush="{StaticResource Brush.Action.Primary}" BorderThickness="1">
                <ScrollViewer VerticalScrollBarVisibility="Auto">
                    <StackPanel Margin="15">
                        <!-- Statistics -->
                        <TextBlock Text="STATISTICS" FontSize="12" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,0,0,10"/>

                        <Grid Margin="0,0,0,20">
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="Auto"/>
                                <ColumnDefinition Width="*"/>
                            </Grid.ColumnDefinitions>
                            <Grid.RowDefinitions>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                            </Grid.RowDefinitions>

                            <TextBlock Grid.Row="0" Grid.Column="0" Text="Average:" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,10,5"/>
                            <TextBlock Grid.Row="0" Grid.Column="1" Text="{Binding AverageEntropy, StringFormat={}{0:F4}}" Foreground="{StaticResource Brush.Action.Primary}" FontWeight="Bold" Margin="0,0,0,5"/>

                            <TextBlock Grid.Row="1" Grid.Column="0" Text="Minimum:" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,10,5"/>
                            <TextBlock Grid.Row="1" Grid.Column="1" Text="{Binding MinEntropy, StringFormat={}{0:F4}}" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,0,0,5"/>

                            <TextBlock Grid.Row="2" Grid.Column="0" Text="Maximum:" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,10,5"/>
                            <TextBlock Grid.Row="2" Grid.Column="1" Text="{Binding MaxEntropy, StringFormat={}{0:F4}}" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,0,0,5"/>

                            <TextBlock Grid.Row="3" Grid.Column="0" Text="Std Dev:" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,10,5"/>
                            <TextBlock Grid.Row="3" Grid.Column="1" Text="{Binding StdDevEntropy, StringFormat={}{0:F4}}" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,0,0,5"/>

                            <TextBlock Grid.Row="4" Grid.Column="0" Text="Chunks:" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,10,5"/>
                            <TextBlock Grid.Row="4" Grid.Column="1" Text="{Binding ChunkCount, StringFormat={}{0:N0}}" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,0,0,5"/>

                            <TextBlock Grid.Row="5" Grid.Column="0" Text="Chunk Size:" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,10,5"/>
                            <TextBlock Grid.Row="5" Grid.Column="1" Text="{Binding ChunkSize}" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,0,0,5"/>
                        </Grid>

                        <!-- File Insights -->
                        <TextBlock Text="FILE INSIGHTS" FontSize="12" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,0,0,10"/>

                        <Border Background="#111" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="1" Padding="10" Margin="0,0,0,20">
                            <StackPanel>
                                <TextBlock Text="{Binding CompressionHint}" Foreground="{StaticResource Brush.Text.Primary}" TextWrapping="Wrap" FontSize="11" Margin="0,0,0,8"/>
                                <TextBlock Text="{Binding EncryptionHint}" Foreground="{StaticResource Brush.Text.Primary}" TextWrapping="Wrap" FontSize="11" Margin="0,0,0,8"/>
                                <TextBlock Text="{Binding DataTypeHint}" Foreground="{StaticResource Brush.Text.Primary}" TextWrapping="Wrap" FontSize="11"/>
                            </StackPanel>
                        </Border>

                        <!-- Export Options -->
                        <TextBlock Text="EXPORT" FontSize="12" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,0,0,10"/>

                        <Button Command="{Binding ExportCsvCommand}" Content="📊 EXPORT CSV" Padding="15,10" Margin="0,0,0,5" FontWeight="Bold" ToolTip="Export entropy data to CSV file"/>

                        <Button Command="{Binding ExportReportCommand}" Content="📄 EXPORT REPORT" Padding="15,10" FontWeight="Bold" ToolTip="Export detailed analysis report"/>
                    </StackPanel>
                </ScrollViewer>
            </Border>
        </Grid>

        <!-- Footer Buttons -->
        <Border Grid.Row="3" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="0,1,0,0" Padding="0,20,0,0" Margin="0,20,0,0">
            <StackPanel Orientation="Horizontal" HorizontalAlignment="Right">
                <Button Command="{Binding RecalculateCommand}" Content="🔄 RECALCULATE" Padding="15,8" Margin="0,0,10,0" FontWeight="Bold" Visibility="{Binding HasResults, Converter={StaticResource BooleanToVisibilityConverter}}"/>
                <Button Content="CLOSE" Click="CloseButton_Click" Padding="20,8" FontWeight="Bold"/>
            </StackPanel>
        </Border>
    </Grid>
</Window>


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWS\ENTROPYANALYSISWINDOW.XAML.CS CODE IS BELOW
using System.Windows;
using DataSpecter.UI.ViewModels;

namespace DataSpecter.UI.Views
{
    public partial class EntropyAnalysisWindow : Window
    {
        public EntropyAnalysisWindow()
        {
            InitializeComponent();
        }

        private void CloseButton_Click(object sender, RoutedEventArgs e)
        {
            Close();
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWS\FILECOMPARISONVIEW.XAML CODE IS BELOW
<UserControl x:Class="DataSpecter.UI.Views.FileComparisonView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:controls="clr-namespace:DataSpecter.UI.Controls" mc:Ignorable="d" d:DesignHeight="450" d:DesignWidth="800">
    <UserControl.Resources>
        <BooleanToVisibilityConverter x:Key="BooleanToVisibilityConverter"/>

        <Style x:Key="LoadingSpinnerStyle" TargetType="Control">
            <Setter Property="Width" Value="40"/>
            <Setter Property="Height" Value="40"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Control">
                        <Grid RenderTransformOrigin="0.5,0.5">
                            <Grid.RenderTransform>
                                <RotateTransform x:Name="SpinTransform" Angle="0"/>
                            </Grid.RenderTransform>
                            <Path Data="M 20 0 A 20 20 0 0 1 40 20" Stroke="{StaticResource Brush.Text.Primary}" StrokeThickness="4" Width="40" Height="40" Stretch="None" HorizontalAlignment="Left" VerticalAlignment="Top"/>
                        </Grid>
                        <ControlTemplate.Triggers>
                            <Trigger Property="Visibility" Value="Visible">
                                <Trigger.EnterActions>
                                    <BeginStoryboard>
                                        <Storyboard>
                                            <DoubleAnimation Storyboard.TargetName="SpinTransform" Storyboard.TargetProperty="Angle" From="0" To="360" Duration="0:0:1" RepeatBehavior="Forever"/>
                                        </Storyboard>
                                    </BeginStoryboard>
                                </Trigger.EnterActions>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </UserControl.Resources>
    <Grid>
        <Grid.Background>
            <RadialGradientBrush GradientOrigin="0.5,0.5" Center="0.5,0.5" RadiusX="1.2" RadiusY="1.2">
                <GradientStop Color="#1a0505" Offset="0.0"/>
                <GradientStop Color="#000000" Offset="1.0"/>
            </RadialGradientBrush>
        </Grid.Background>

        <Path Data="M12,2A9,9 0 0,0 3,11C3,14.03 4.53,16.82 7,18.47V22H9V19H11V22H13V19H15V22H17V18.46C19.47,16.81 21,14 21,11A9,9 0 0,0 12,2M8,11A2,2 0 0,1 10,13A2,2 0 0,1 8,15A2,2 0 0,1 6,13A2,2 0 0,1 8,11M16,11A2,2 0 0,1 18,13A2,2 0 0,1 16,15A2,2 0 0,1 14,13A2,2 0 0,1 16,11M12,14H14V17H10V14H12Z" Fill="#33FF0000" Stretch="Uniform" Width="450" Height="450" HorizontalAlignment="Center" VerticalAlignment="Center" Opacity="0.08" IsHitTestVisible="False">
            <Path.Effect>
                <DropShadowEffect Color="#FF0000" BlurRadius="50" ShadowDepth="0" Opacity="0.5"/>
            </Path.Effect>
        </Path>

        <Canvas x:Name="ParticleCanvas" IsHitTestVisible="False" ClipToBounds="True"/>

        <Grid Margin="20">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="*"/>
            </Grid.RowDefinitions>

            <StackPanel Grid.Row="0">
                <TextBlock Text="Cross-Evidence Analysis" FontSize="24" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}"/>
                <TextBlock Text="Compare files using LCS (Longest Common Substring) and SSDEEP Fuzzy Hashing" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,0,20"/>
            </StackPanel>

            <Grid Grid.Row="1" Margin="0,0,0,20">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="20"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>

                <!-- File 1 -->
                <Border Grid.Column="0" BorderBrush="Green" BorderThickness="1" Background="#052205" CornerRadius="4" Padding="15">
                    <StackPanel>
                        <TextBlock Text="BASELINE FILE" FontSize="10" Foreground="Green" FontWeight="Bold"/>
                        <ComboBox ItemsSource="{Binding Files}" SelectedItem="{Binding SelectedFile1}" DisplayMemberPath="Name" Margin="0,10,0,0"/>
                    </StackPanel>
                </Border>

                <!-- File 2 -->
                <Border Grid.Column="2" BorderBrush="Red" BorderThickness="1" Background="#220505" CornerRadius="4" Padding="15">
                    <StackPanel>
                        <TextBlock Text="SUSPECT FILE" FontSize="10" Foreground="Red" FontWeight="Bold"/>
                        <ComboBox ItemsSource="{Binding Files}" SelectedItem="{Binding SelectedFile2}" DisplayMemberPath="Name" Margin="0,10,0,0"/>
                    </StackPanel>
                </Border>
            </Grid>

            <Button Grid.Row="2" Command="{Binding CompareCommand}" Content="EXECUTE DIFFERENTIAL ANALYSIS" HorizontalAlignment="Center" Padding="20,10" FontWeight="Bold" Margin="0,0,0,20"/>

            <!-- Viewers & Results -->
            <Grid Grid.Row="3">
                <!-- Loading Overlay -->
                <Grid Panel.ZIndex="10" Background="#88000000" Visibility="{Binding IsCalculating, Converter={StaticResource BooleanToVisibilityConverter}}">
                    <StackPanel VerticalAlignment="Center" HorizontalAlignment="Center">
                        <Control Style="{StaticResource LoadingSpinnerStyle}"/>
                        <TextBlock Text="Analyzing Byte Patterns..." Foreground="White" Margin="0,10,0,0" FontWeight="Bold"/>
                    </StackPanel>
                </Grid>

                <!-- Results Container -->
                <Grid Visibility="{Binding IsResultReady, Converter={StaticResource BooleanToVisibilityConverter}}" RenderTransformOrigin="0.5,0.5">
                    <Grid.RenderTransform>
                        <TranslateTransform Y="50"/>
                    </Grid.RenderTransform>
                    <Grid.Style>
                        <Style TargetType="Grid">
                            <Style.Triggers>
                                <DataTrigger Binding="{Binding IsResultReady}" Value="True">
                                    <DataTrigger.EnterActions>
                                        <BeginStoryboard>
                                            <Storyboard>
                                                <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(TranslateTransform.Y)" To="0" Duration="0:0:0.5" DecelerationRatio="0.5"/>
                                                <DoubleAnimation Storyboard.TargetProperty="Opacity" From="0" To="1" Duration="0:0:0.5"/>
                                            </Storyboard>
                                        </BeginStoryboard>
                                    </DataTrigger.EnterActions>
                                </DataTrigger>
                            </Style.Triggers>
                        </Style>
                    </Grid.Style>

                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="*"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>

                    <!-- Metrics Header -->
                    <Border Grid.Row="0" Background="#222" CornerRadius="4" Padding="10" Margin="0,0,0,10">
                        <StackPanel>
                            <!-- LCS Results -->
                            <StackPanel Orientation="Horizontal" HorizontalAlignment="Center" Margin="0,0,0,10">
                                <TextBlock Text="LCS Analysis: " Foreground="#AAA" FontWeight="Bold"/>
                                <TextBlock Text="{Binding ComparisonDuration.TotalMilliseconds, StringFormat={}{0:F0}ms}" Foreground="White" FontWeight="Bold" Margin="5,0,15,0"/>
                                <TextBlock Text="Match Length: " Foreground="#AAA"/>
                                <TextBlock Text="{Binding LcsLength, StringFormat={}{0:N0} Bytes}" Foreground="#FFD700" FontWeight="Bold"/>
                            </StackPanel>

                            <!-- Fuzzy Hash Results -->
                            <Border Background="#0a0a0a" BorderBrush="{StaticResource Brush.Action.Primary}" BorderThickness="1" CornerRadius="3" Padding="15" Margin="0,5,0,10" Visibility="{Binding IsFuzzyHashCalculated, Converter={StaticResource BooleanToVisibilityConverter}}">
                                <Grid>
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="*"/>
                                        <ColumnDefinition Width="*"/>
                                        <ColumnDefinition Width="2*"/>
                                    </Grid.ColumnDefinitions>

                                    <!-- SSDEEP Score -->
                                    <StackPanel Grid.Column="0" HorizontalAlignment="Center">
                                        <TextBlock Text="SSDEEP" FontSize="9" Foreground="{StaticResource Brush.Text.Muted}" HorizontalAlignment="Center" Margin="0,0,0,5"/>
                                        <TextBlock Text="{Binding SsdeepScore, StringFormat={}{0}%}" FontSize="32" FontWeight="Bold" Foreground="{StaticResource Brush.Action.Primary}" HorizontalAlignment="Center"/>
                                        <TextBlock Text="{Binding SsdeepScoreDescription}" FontSize="9" Foreground="{StaticResource Brush.Text.Muted}" HorizontalAlignment="Center" Margin="0,3,0,0"/>
                                    </StackPanel>

                                    <!-- Byte-Level Score -->
                                    <StackPanel Grid.Column="1" HorizontalAlignment="Center">
                                        <TextBlock Text="Byte-Level" FontSize="9" Foreground="{StaticResource Brush.Text.Muted}" HorizontalAlignment="Center" Margin="0,0,0,5"/>
                                        <TextBlock Text="{Binding ByteLevelScore, StringFormat={}{0:F1}%}" FontSize="32" FontWeight="Bold" Foreground="{StaticResource Brush.Status.Success}" HorizontalAlignment="Center"/>
                                        <TextBlock Text="{Binding ByteLevelScoreDescription}" FontSize="9" Foreground="{StaticResource Brush.Text.Muted}" HorizontalAlignment="Center" Margin="0,3,0,0"/>
                                    </StackPanel>

                                    <!-- Insight -->
                                    <Border Grid.Column="2" Background="#111" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="1" CornerRadius="3" Padding="10" Margin="10,0,0,0">
                                        <StackPanel>
                                            <TextBlock Text="SIMILARITY INSIGHT" FontSize="9" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,0,5"/>
                                            <TextBlock Text="{Binding SimilarityInsight}" FontSize="10" Foreground="{StaticResource Brush.Text.Primary}" TextWrapping="Wrap"/>
                                        </StackPanel>
                                    </Border>
                                </Grid>
                            </Border>

                            <!-- Comparison Visualizer -->
                            <controls:ComparisonVisualizer File1Length="{Binding File1Length}" File2Length="{Binding File2Length}" MatchOffset="{Binding LcsOffset1}" MatchOffset2="{Binding LcsOffset2}" MatchLength="{Binding LcsLength}" MatchRegionClicked="ComparisonVisualizer_MatchRegionClicked" Margin="0,5,0,0"/>

                            <TextBlock Text="Click the highlighted region to jump to match location" Foreground="{StaticResource Brush.Text.Muted}" FontSize="10" HorizontalAlignment="Center" Margin="0,5,0,0" FontStyle="Italic"/>
                        </StackPanel>
                    </Border>

                    <!-- Viewers -->
                    <Grid Grid.Row="1">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="20"/>
                            <ColumnDefinition Width="*"/>
                        </Grid.ColumnDefinitions>

                        <!-- Viewer 1 -->
                        <Border Grid.Column="0" Background="#111" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="1" CornerRadius="4" Padding="10">
                            <Grid>
                                <Grid.RowDefinitions>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="*"/>
                                </Grid.RowDefinitions>
                                <TextBlock Text="BASELINE HEX" Foreground="Green" FontWeight="Bold" Margin="0,0,0,10"/>
                                <controls:HexViewer Grid.Row="1" Bytes="{Binding HexData1}" Title="BASELINE DATA" ScrollToOffset="{Binding ScrollOffset1}"/>

                                <StackPanel Grid.Row="1" VerticalAlignment="Bottom" HorizontalAlignment="Right" Margin="10">
                                    <TextBlock Text="{Binding LcsOffset1, StringFormat={}Match Offset: 0x{0:X}}" Foreground="Green" FontWeight="Bold" Background="#111"/>
                                </StackPanel>
                            </Grid>
                        </Border>

                        <!-- Viewer 2 -->
                        <Border Grid.Column="2" Background="#111" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="1" CornerRadius="4" Padding="10">
                            <Grid>
                                <Grid.RowDefinitions>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="*"/>
                                </Grid.RowDefinitions>
                                <TextBlock Text="SUSPECT HEX" Foreground="Red" FontWeight="Bold" Margin="0,0,0,10"/>
                                <controls:HexViewer Grid.Row="1" Bytes="{Binding HexData2}" Title="SUSPECT DATA" ScrollToOffset="{Binding ScrollOffset2}"/>

                                <StackPanel Grid.Row="1" VerticalAlignment="Bottom" HorizontalAlignment="Right" Margin="10">
                                    <TextBlock Text="{Binding LcsOffset2, StringFormat={}Match Offset: 0x{0:X}}" Foreground="Red" FontWeight="Bold" Background="#111"/>
                                </StackPanel>
                            </Grid>
                        </Border>
                    </Grid>

                    <!-- Raw Content -->
                    <Border Grid.Row="2" Margin="0,10,0,0" Background="#111" BorderBrush="#333" BorderThickness="1" CornerRadius="4" Padding="10">
                        <StackPanel>
                            <TextBlock Text="MATCHED CONTENT (ASCII PREVIEW)" FontSize="10" FontWeight="Bold" Foreground="#AAA" Margin="0,0,0,5"/>
                            <TextBlock Text="{Binding LcsText}" FontFamily="Consolas" Foreground="#FFD700" TextWrapping="Wrap"/>
                        </StackPanel>
                    </Border>
                </Grid>
            </Grid>
        </Grid>
    </Grid>
</UserControl>


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWS\FILECOMPARISONVIEW.XAML.CS CODE IS BELOW
using System;
using System.Windows;
using System.Windows.Controls;
using DataSpecter.UI.ViewModels;

namespace DataSpecter.UI.Views
{
    public partial class FileComparisonView : UserControl
    {
        public FileComparisonView()
        {
            InitializeComponent();
        }

        private void ComparisonVisualizer_MatchRegionClicked(object sender, EventArgs e)
        {
            // Scroll both hex viewers to show the matching content
            if (DataContext is FileComparisonViewModel viewModel)
            {
                viewModel.ScrollToMatchCommand.Execute(null);
            }
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWS\FILEMANAGEMENTVIEW.XAML CODE IS BELOW
<UserControl x:Class="DataSpecter.UI.Views.FileManagementView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008" mc:Ignorable="d" d:DesignHeight="450" d:DesignWidth="800">
    <Grid>
        <Grid.Background>
            <RadialGradientBrush GradientOrigin="0.5,0.5" Center="0.5,0.5" RadiusX="1.2" RadiusY="1.2">
                <GradientStop Color="#1a0505" Offset="0.0"/>
                <GradientStop Color="#000000" Offset="1.0"/>
            </RadialGradientBrush>
        </Grid.Background>

        <Path Data="M12,2A9,9 0 0,0 3,11C3,14.03 4.53,16.82 7,18.47V22H9V19H11V22H13V19H15V22H17V18.46C19.47,16.81 21,14 21,11A9,9 0 0,0 12,2M8,11A2,2 0 0,1 10,13A2,2 0 0,1 8,15A2,2 0 0,1 6,13A2,2 0 0,1 8,11M16,11A2,2 0 0,1 18,13A2,2 0 0,1 16,15A2,2 0 0,1 14,13A2,2 0 0,1 16,11M12,14H14V17H10V14H12Z" Fill="#33FF0000" Stretch="Uniform" Width="450" Height="450" HorizontalAlignment="Center" VerticalAlignment="Center" Opacity="0.08" IsHitTestVisible="False">
            <Path.Effect>
                <DropShadowEffect Color="#FF0000" BlurRadius="50" ShadowDepth="0" Opacity="0.5"/>
            </Path.Effect>
        </Path>

        <Canvas x:Name="ParticleCanvas" IsHitTestVisible="False" ClipToBounds="True"/>

        <StackPanel Margin="20">
            <Grid>
                <StackPanel>
                    <TextBlock Text="Evidence Vault" FontSize="24" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}"/>
                    <TextBlock Text="Persistent Storage Management" Foreground="{StaticResource Brush.Text.Muted}"/>
                </StackPanel>
                <StackPanel HorizontalAlignment="Right">
                    <TextBlock Text="Vault Size" FontSize="10" Foreground="{StaticResource Brush.Text.Muted}" HorizontalAlignment="Right"/>
                    <TextBlock Text="{Binding TotalSizeMB, StringFormat={}{0:F2} MB}" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}" HorizontalAlignment="Right"/>
                </StackPanel>
            </Grid>

            <DataGrid ItemsSource="{Binding Files}" AutoGenerateColumns="False" Margin="0,20,0,0" Background="Transparent" BorderThickness="0" RowBackground="Transparent" CanUserAddRows="False" HeadersVisibility="Column" GridLinesVisibility="Horizontal" HorizontalGridLinesBrush="{StaticResource Brush.Panel.Border}">
                <DataGrid.Resources>
                    <Style TargetType="DataGridColumnHeader">
                        <Setter Property="Background" Value="{StaticResource Brush.Panel.Background}"/>
                        <Setter Property="Foreground" Value="{StaticResource Brush.Text.Muted}"/>
                        <Setter Property="Padding" Value="10,5"/>
                        <Setter Property="FontSize" Value="10"/>
                        <Setter Property="FontWeight" Value="Bold"/>
                    </Style>
                    <Style TargetType="DataGridCell">
                        <Setter Property="Foreground" Value="{StaticResource Brush.Text.Primary}"/>
                        <Setter Property="Padding" Value="10"/>
                        <Setter Property="BorderThickness" Value="0"/>
                        <Setter Property="Template">
                            <Setter.Value>
                                <ControlTemplate TargetType="DataGridCell">
                                    <Border Padding="{TemplateBinding Padding}" Background="{TemplateBinding Background}">
                                        <ContentPresenter />
                                    </Border>
                                </ControlTemplate>
                            </Setter.Value>
                        </Setter>
                    </Style>
                </DataGrid.Resources>
                <DataGrid.Columns>
                    <DataGridTextColumn Header="EVIDENCE NAME" Binding="{Binding Name}" Width="2*"/>
                    <DataGridTextColumn Header="SYSTEM PATH" Binding="{Binding Path}" Width="3*"/>
                    <DataGridTextColumn Header="SIZE (Bytes)" Binding="{Binding Size}" Width="1*"/>
                    <DataGridTextColumn Header="STATUS" Binding="{Binding Status}" Width="1*"/>
                    <DataGridTemplateColumn Header="ACTIONS" Width="Auto">
                        <DataGridTemplateColumn.CellTemplate>
                            <DataTemplate>
                                <Button Command="{Binding DataContext.DeleteFileCommand, RelativeSource={RelativeSource AncestorType=UserControl}}" CommandParameter="{Binding}" Content="Delete" Background="Transparent" Foreground="White" BorderThickness="0"/>
                            </DataTemplate>
                        </DataGridTemplateColumn.CellTemplate>
                    </DataGridTemplateColumn>
                </DataGrid.Columns>
            </DataGrid>
        </StackPanel>
    </Grid>
</UserControl>


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWS\FILEMANAGEMENTVIEW.XAML.CS CODE IS BELOW
using System.Windows.Controls;

namespace DataSpecter.UI.Views
{
    public partial class FileManagementView : UserControl
    {
        public FileManagementView()
        {
            InitializeComponent();
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWS\FILESIMILARITYWINDOW.XAML CODE IS BELOW
<Window x:Class="DataSpecter.UI.Views.FileSimilarityWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="d" Title="File Similarity Analysis (Fuzzy Hashing)" Height="750" Width="1100" Background="{StaticResource Brush.Panel.Background}" WindowStartupLocation="CenterOwner" ResizeMode="CanResize">

    <Window.Resources>
        <BooleanToVisibilityConverter x:Key="BooleanToVisibilityConverter"/>
    </Window.Resources>

    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Header -->
        <StackPanel Grid.Row="0" Margin="0,0,0,20">
            <TextBlock Text="FILE SIMILARITY ANALYSIS" FontSize="24" FontWeight="Bold" Foreground="{StaticResource Brush.Action.Primary}"/>
            <TextBlock Text="Using SSDEEP Fuzzy Hashing &amp; Byte-Level Comparison" FontSize="12" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,5,0,0"/>
        </StackPanel>

        <!-- File Selection -->
        <Border Grid.Row="1" Background="#111" BorderBrush="{StaticResource Brush.Action.Primary}" BorderThickness="1" Padding="15" Margin="0,0,0,20">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="20"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>

                <!-- File 1 -->
                <StackPanel Grid.Row="0" Grid.Column="0">
                    <TextBlock Text="FILE 1" FontSize="10" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,0,5"/>
                    <ComboBox ItemsSource="{Binding AvailableFiles}" SelectedItem="{Binding File1}" DisplayMemberPath="Name" Margin="0,0,0,5"/>
                    <TextBlock Text="{Binding File1Size}" Foreground="{StaticResource Brush.Text.Muted}" FontSize="10"/>
                </StackPanel>

                <!-- VS -->
                <TextBlock Grid.Row="0" Grid.Column="1" Text="VS" FontSize="16" FontWeight="Bold" Foreground="{StaticResource Brush.Action.Primary}" HorizontalAlignment="Center" VerticalAlignment="Center"/>

                <!-- File 2 -->
                <StackPanel Grid.Row="0" Grid.Column="2">
                    <TextBlock Text="FILE 2" FontSize="10" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,0,5"/>
                    <ComboBox ItemsSource="{Binding AvailableFiles}" SelectedItem="{Binding File2}" DisplayMemberPath="Name" Margin="0,0,0,5"/>
                    <TextBlock Text="{Binding File2Size}" Foreground="{StaticResource Brush.Text.Muted}" FontSize="10"/>
                </StackPanel>

                <!-- Compare Button -->
                <Button Grid.Row="1" Grid.Column="0" Grid.ColumnSpan="3" Command="{Binding CompareCommand}" Content="🔍 COMPARE FILES" Padding="20,10" Margin="0,15,0,0" FontWeight="Bold" FontSize="14" HorizontalAlignment="Center"/>
            </Grid>
        </Border>

        <!-- Progress -->
        <Border Grid.Row="2" Background="#111" BorderBrush="{StaticResource Brush.Action.Primary}" BorderThickness="1" Padding="20" Visibility="{Binding IsComparing, Converter={StaticResource BooleanToVisibilityConverter}}">
            <StackPanel VerticalAlignment="Center">
                <TextBlock Text="{Binding ComparisonStatus}" Foreground="{StaticResource Brush.Text.Primary}" FontSize="14" HorizontalAlignment="Center" Margin="0,0,0,15"/>
                <ProgressBar Value="{Binding ComparisonProgress}" Maximum="100" Height="10" Width="400" Background="#333" Foreground="{StaticResource Brush.Action.Primary}"/>
            </StackPanel>
        </Border>

        <!-- Results -->
        <ScrollViewer Grid.Row="2" VerticalScrollBarVisibility="Auto" Visibility="{Binding HasResults, Converter={StaticResource BooleanToVisibilityConverter}}">
            <StackPanel>
                <!-- Overall Similarity Score -->
                <Border Background="#0a0a0a" BorderBrush="{StaticResource Brush.Action.Primary}" BorderThickness="2" Padding="20" Margin="0,0,0,15">
                    <StackPanel>
                        <TextBlock Text="OVERALL SIMILARITY SCORE" FontSize="14" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}" HorizontalAlignment="Center" Margin="0,0,0,15"/>

                        <Grid>
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="*"/>
                                <ColumnDefinition Width="*"/>
                            </Grid.ColumnDefinitions>

                            <!-- SSDEEP Score -->
                            <StackPanel Grid.Column="0" HorizontalAlignment="Center">
                                <TextBlock Text="Fuzzy Hash (SSDEEP)" FontSize="11" Foreground="{StaticResource Brush.Text.Muted}" HorizontalAlignment="Center" Margin="0,0,0,10"/>
                                <TextBlock Text="{Binding SsdeepScore, StringFormat={}{0}%}" FontSize="48" FontWeight="Bold" Foreground="{StaticResource Brush.Action.Primary}" HorizontalAlignment="Center"/>
                                <TextBlock Text="{Binding SsdeepScoreDescription}" FontSize="10" Foreground="{StaticResource Brush.Text.Muted}" HorizontalAlignment="Center" Margin="0,5,0,0"/>
                            </StackPanel>

                            <!-- Byte-Level Score -->
                            <StackPanel Grid.Column="1" HorizontalAlignment="Center">
                                <TextBlock Text="Byte-Level Analysis" FontSize="11" Foreground="{StaticResource Brush.Text.Muted}" HorizontalAlignment="Center" Margin="0,0,0,10"/>
                                <TextBlock Text="{Binding ByteLevelScore, StringFormat={}{0:F2}%}" FontSize="48" FontWeight="Bold" Foreground="{StaticResource Brush.Status.Success}" HorizontalAlignment="Center"/>
                                <TextBlock Text="{Binding ByteLevelScoreDescription}" FontSize="10" Foreground="{StaticResource Brush.Text.Muted}" HorizontalAlignment="Center" Margin="0,5,0,0"/>
                            </StackPanel>
                        </Grid>
                    </StackPanel>
                </Border>

                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>

                    <!-- Left Column: Fuzzy Hashes -->
                    <Border Grid.Column="0" Background="#0a0a0a" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="1" Padding="15" Margin="0,0,7.5,15">
                        <StackPanel>
                            <TextBlock Text="FUZZY HASHES (SSDEEP)" FontSize="12" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,0,0,15"/>

                            <TextBlock Text="File 1:" FontSize="10" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,0,5"/>
                            <Border Background="#111" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="1" Padding="10" Margin="0,0,0,15">
                                <TextBlock Text="{Binding FuzzyHash1}" FontFamily="Consolas" FontSize="10" Foreground="{StaticResource Brush.Text.Primary}" TextWrapping="Wrap"/>
                            </Border>

                            <TextBlock Text="File 2:" FontSize="10" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,0,5"/>
                            <Border Background="#111" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="1" Padding="10">
                                <TextBlock Text="{Binding FuzzyHash2}" FontFamily="Consolas" FontSize="10" Foreground="{StaticResource Brush.Text.Primary}" TextWrapping="Wrap"/>
                            </Border>
                        </StackPanel>
                    </Border>

                    <!-- Right Column: Byte-Level Statistics -->
                    <Border Grid.Column="1" Background="#0a0a0a" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="1" Padding="15" Margin="7.5,0,0,15">
                        <StackPanel>
                            <TextBlock Text="BYTE-LEVEL STATISTICS" FontSize="12" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,0,0,15"/>

                            <Grid>
                                <Grid.ColumnDefinitions>
                                    <ColumnDefinition Width="Auto"/>
                                    <ColumnDefinition Width="*"/>
                                </Grid.ColumnDefinitions>
                                <Grid.RowDefinitions>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                    <RowDefinition Height="Auto"/>
                                </Grid.RowDefinitions>

                                <TextBlock Grid.Row="0" Grid.Column="0" Text="Common Chunks:" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,10,8"/>
                                <TextBlock Grid.Row="0" Grid.Column="1" Text="{Binding CommonChunksCount, StringFormat={}{0:N0}}" Foreground="{StaticResource Brush.Text.Primary}" FontWeight="Bold" Margin="0,0,0,8"/>

                                <TextBlock Grid.Row="1" Grid.Column="0" Text="Bytes Analyzed:" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,10,8"/>
                                <TextBlock Grid.Row="1" Grid.Column="1" Text="{Binding BytesAnalyzed}" Foreground="{StaticResource Brush.Text.Primary}" FontWeight="Bold" Margin="0,0,0,8"/>

                                <TextBlock Grid.Row="2" Grid.Column="0" Text="Longest Match:" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,10,8"/>
                                <TextBlock Grid.Row="2" Grid.Column="1" Text="{Binding LongestMatchLength}" Foreground="{StaticResource Brush.Text.Primary}" FontWeight="Bold" Margin="0,0,0,8"/>

                                <TextBlock Grid.Row="3" Grid.Column="0" Text="Match at File 1:" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,10,8"/>
                                <TextBlock Grid.Row="3" Grid.Column="1" Text="{Binding MatchOffset1}" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,0,0,8"/>

                                <TextBlock Grid.Row="4" Grid.Column="0" Text="Match at File 2:" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,10,8"/>
                                <TextBlock Grid.Row="4" Grid.Column="1" Text="{Binding MatchOffset2}" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,0,0,8"/>

                                <TextBlock Grid.Row="5" Grid.Column="0" Text="Analysis Time:" Foreground="{StaticResource Brush.Text.Muted}" Margin="0,0,10,8"/>
                                <TextBlock Grid.Row="5" Grid.Column="1" Text="{Binding AnalysisTime}" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,0,0,8"/>
                            </Grid>
                        </StackPanel>
                    </Border>
                </Grid>

                <!-- Analysis Insights -->
                <Border Background="#0a0a0a" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="1" Padding="15" Margin="0,0,0,15">
                    <StackPanel>
                        <TextBlock Text="ANALYSIS INSIGHTS" FontSize="12" FontWeight="Bold" Foreground="{StaticResource Brush.Text.Primary}" Margin="0,0,0,10"/>

                        <TextBlock Text="{Binding SimilarityInsight}" Foreground="{StaticResource Brush.Text.Primary}" TextWrapping="Wrap" FontSize="11" Margin="0,0,0,8"/>

                        <TextBlock Text="{Binding FuzzyHashInsight}" Foreground="{StaticResource Brush.Text.Primary}" TextWrapping="Wrap" FontSize="11" Margin="0,0,0,8"/>

                        <TextBlock Text="{Binding ByteLevelInsight}" Foreground="{StaticResource Brush.Text.Primary}" TextWrapping="Wrap" FontSize="11"/>
                    </StackPanel>
                </Border>

                <!-- Export Options -->
                <StackPanel Orientation="Horizontal" HorizontalAlignment="Center">
                    <Button Command="{Binding ExportReportCommand}" Content="📄 EXPORT REPORT" Padding="15,8" Margin="0,0,10,0" FontWeight="Bold"/>

                    <Button Command="{Binding NavigateToMatchCommand}" Content="🎯 VIEW LONGEST MATCH" Padding="15,8" FontWeight="Bold" Visibility="{Binding HasLongestMatch, Converter={StaticResource BooleanToVisibilityConverter}}"/>
                </StackPanel>
            </StackPanel>
        </ScrollViewer>

        <!-- Footer -->
        <Border Grid.Row="3" BorderBrush="{StaticResource Brush.Panel.Border}" BorderThickness="0,1,0,0" Padding="0,15,0,0" Margin="0,15,0,0">
            <Button Content="CLOSE" Click="CloseButton_Click" Padding="20,8" FontWeight="Bold" HorizontalAlignment="Right"/>
        </Border>
    </Grid>
</Window>


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWS\FILESIMILARITYWINDOW.XAML.CS CODE IS BELOW
using System.Windows;

namespace DataSpecter.UI.Views
{
    public partial class FileSimilarityWindow : Window
    {
        public FileSimilarityWindow()
        {
            InitializeComponent();
        }

        private void CloseButton_Click(object sender, RoutedEventArgs e)
        {
            Close();
        }
    }
}


C:\USERS\999AD\SOURCE\REPOS\DATASPECTER\DATASPECTER.UI\VIEWS\GLASSBORDER.CS CODE IS BELOW
﻿using System;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Media;

namespace DataSpecter.UI.Views
{
    // FIX: Inherit from ContentControl, not Border, to support Templates
    public class GlassBorder : ContentControl
    {
        private VisualBrush _glassBrush;
        private TranslateTransform _translateTransform;

        // 1. Scope Property (The element to blur)
        public static readonly DependencyProperty ScopeProperty =
            DependencyProperty.Register("Scope", typeof(UIElement), typeof(GlassBorder),
                new PropertyMetadata(null, OnScopeChanged));

        public UIElement Scope
        {
            get { return (UIElement)GetValue(ScopeProperty); }
            set { SetValue(ScopeProperty, value); }
        }

        // 2. CornerRadius Property (ContentControl doesn't have this by default)
        public static readonly DependencyProperty CornerRadiusProperty =
            DependencyProperty.Register("CornerRadius", typeof(CornerRadius), typeof(GlassBorder),
                new PropertyMetadata(new CornerRadius(0)));

        public CornerRadius CornerRadius
        {
            get { return (CornerRadius)GetValue(CornerRadiusProperty); }
            set { SetValue(CornerRadiusProperty, value); }
        }

        public GlassBorder()
        {
            _translateTransform = new TranslateTransform();
            _glassBrush = new VisualBrush
            {
                Stretch = Stretch.None,
                AlignmentX = AlignmentX.Left,
                AlignmentY = AlignmentY.Top,
                Transform = _translateTransform
            };

            // Set the brush as the background (accessed via TemplateBinding later)
            this.Background = _glassBrush;
            this.LayoutUpdated += OnLayoutUpdated;
        }

        private static void OnScopeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var border = (GlassBorder)d;
            if (e.NewValue is UIElement scope)
            {
                border._glassBrush.Visual = scope;
            }
        }

        private void OnLayoutUpdated(object sender, EventArgs e)
        {
            if (Scope == null) return;

            try
            {
                var transform = this.TransformToVisual(Scope);
                Point offset = transform.Transform(new Point(0, 0));

                _translateTransform.X = -offset.X;
                _translateTransform.Y = -offset.Y;
            }
            catch
            {
                // Visual tree not ready
            }
        }
    }
}
